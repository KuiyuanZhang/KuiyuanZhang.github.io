<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-mac-osx.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  
    
      
    

    
  

  

  

  
    
      
    

    
  

  
    
    
    <link href="https://fonts.cat.net/css?family=Lato:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">


  <link rel="manifest" href="/images/manifest.json">


  <meta name="msapplication-config" content="/images/browserconfig.xml" />



  <meta name="keywords" content="Python,Seaborn," />





  <link rel="alternate" href="/atom.xml" title="Kuiyuan's Blog" type="application/atom+xml" />






<meta name="description" content="python绘图软件seaborn的常用介绍 官方文档： seaborn官方文档 以下是常用功能  import语句1import searborn as sns">
<meta name="keywords" content="Python,Seaborn">
<meta property="og:type" content="article">
<meta property="og:title" content="必备神器之seaborn">
<meta property="og:url" content="http://yoursite.com/2018/02/08/必备神器之seaborn/index.html">
<meta property="og:site_name" content="Kuiyuan&#39;s Blog">
<meta property="og:description" content="python绘图软件seaborn的常用介绍 官方文档： seaborn官方文档 以下是常用功能  import语句1import searborn as sns">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://pic1.zhimg.com/80/v2-96e264d6b87333b0fb5db977588998f7_hd.jpg">
<meta property="og:image" content="https://pic2.zhimg.com/80/v2-d0e5a4d24a0bcbe01d9c2fd995ae6099_hd.jpg">
<meta property="og:image" content="https://pic4.zhimg.com/80/v2-436b148a808465534752b0e2f0cd127e_hd.jpg">
<meta property="og:image" content="https://pic1.zhimg.com/80/v2-c180b44ec34056361c705928b083715a_hd.jpg">
<meta property="og:image" content="https://pic2.zhimg.com/80/v2-12960e1a69df3f22bde993970a446655_hd.jpg">
<meta property="og:image" content="https://pic2.zhimg.com/80/v2-050c042daedc78711c5d1e34c1d01cba_hd.jpg">
<meta property="og:image" content="https://pic2.zhimg.com/80/v2-6ff1e678229d4f1068153b36c7e3fc9e_hd.jpg">
<meta property="og:image" content="https://pic3.zhimg.com/80/v2-e3b1dd4ffa6601e8b9955b12b2550d16_hd.jpg">
<meta property="og:image" content="https://pic1.zhimg.com/80/v2-11a06ec6f0fbb3e18f6db83f7a288c63_hd.jpg">
<meta property="og:image" content="https://pic1.zhimg.com/80/v2-a36d19c549a4ea5a6bca0743ef7fec8c_hd.jpg">
<meta property="og:image" content="https://pic4.zhimg.com/80/v2-074042f10a2a586a7c89b70bdde41f0e_hd.jpg">
<meta property="og:image" content="https://pic2.zhimg.com/80/v2-657ac986e339294193453407806f9fca_hd.jpg">
<meta property="og:image" content="https://pic2.zhimg.com/80/v2-f9d617e2bdd21320b07a9dbe2ba7098f_hd.jpg">
<meta property="og:image" content="https://pic3.zhimg.com/80/v2-89d18849932e697a973ee04d8216af1d_hd.jpg">
<meta property="og:image" content="https://pic4.zhimg.com/80/v2-4098205f7671ffc7dd72c54d11e8a27e_hd.jpg">
<meta property="og:image" content="https://pic4.zhimg.com/80/v2-dd92bb2302af238bd4887185749ba278_hd.jpg">
<meta property="og:image" content="https://pic3.zhimg.com/80/v2-207352f0a3a968fdb8ab6f33d5b1b9e4_hd.jpg">
<meta property="og:image" content="https://pic3.zhimg.com/80/v2-5ad4013ce278d06d9bc1c633b5e740d9_hd.jpg">
<meta property="og:image" content="https://pic4.zhimg.com/80/v2-ba711a8887d5d3d217123c0796741c1b_hd.jpg">
<meta property="og:image" content="https://pic2.zhimg.com/80/v2-f85e33b615f3f20cd930d8722f9feb26_hd.jpg">
<meta property="og:image" content="https://pic7.zhimg.com/80/v2-1bed7a99683ef5c944c2fe5a13d703ff_hd.jpg">
<meta property="og:image" content="https://pic4.zhimg.com/80/v2-24fcd5ec6caeb4b685d66cdbe86d41fe_hd.jpg">
<meta property="og:image" content="https://pic3.zhimg.com/80/v2-3a8badc7c6ddf7f470ba89687e6835f4_hd.jpg">
<meta property="og:image" content="https://pic1.zhimg.com/80/v2-906e0e32ab89e6301fa0a19a24e98ec5_hd.jpg">
<meta property="og:image" content="https://pic1.zhimg.com/80/v2-851229aebdd9a4256c954f62fafae005_hd.jpg">
<meta property="og:image" content="https://pic3.zhimg.com/80/v2-b9eecc1da38590eea5e0cf978f509ca8_hd.jpg">
<meta property="og:image" content="https://pic1.zhimg.com/80/v2-906536f92686620044e429423a774ffb_hd.jpg">
<meta property="og:image" content="https://pic1.zhimg.com/80/v2-e5db2fc83e78b3090d4d9db3f42e2891_hd.jpg">
<meta property="og:image" content="https://pic1.zhimg.com/80/v2-a4d334b52b4ce7fea79631b57b6ec23e_hd.jpg">
<meta property="og:image" content="https://pic3.zhimg.com/80/v2-f7df28002ee1abbd27d8ffa2f9b5e906_hd.jpg">
<meta property="og:image" content="https://pic3.zhimg.com/80/v2-5ffe4b697daf3596acaceb42b592f542_hd.jpg">
<meta property="og:image" content="https://pic1.zhimg.com/80/v2-e339949a2efaeef4c4384bf5e7534ae4_hd.jpg">
<meta property="og:image" content="https://pic2.zhimg.com/80/v2-8c0cb56d05cc65498bffcb87164d055e_hd.jpg">
<meta property="og:image" content="https://pic4.zhimg.com/80/v2-66b181cb9d4fe29d58aaaaacd0fdacaf_hd.jpg">
<meta property="og:image" content="https://pic1.zhimg.com/80/v2-89c5b6e8210e426717b1c3dafc39e4b7_hd.jpg">
<meta property="og:image" content="https://pic4.zhimg.com/80/v2-8a7dec638c0844e117a25c889e7324fc_hd.jpg">
<meta property="og:image" content="https://pic2.zhimg.com/80/v2-ef09b91ef4b313522a7915f2b41a5fdd_hd.jpg">
<meta property="og:image" content="https://pic1.zhimg.com/80/v2-b9c0c3be1f396f59d225a31eb1fd2a0d_hd.jpg">
<meta property="og:image" content="https://pic1.zhimg.com/80/v2-8bf2abd6be5eb2703826fa778d73584b_hd.jpg">
<meta property="og:image" content="https://pic2.zhimg.com/80/v2-2182193b71a409e7167973482029a86c_hd.jpg">
<meta property="og:image" content="https://pic2.zhimg.com/80/v2-d6aaa2f056c643055fc4ced364c2c910_hd.jpg">
<meta property="og:image" content="https://pic2.zhimg.com/80/v2-66a8b888f654677f08317e3a40af068d_hd.jpg">
<meta property="og:image" content="https://pic3.zhimg.com/80/v2-06b20374bc180f9e18dd80c73f825923_hd.jpg">
<meta property="og:image" content="https://pic3.zhimg.com/80/v2-82c566f9a56048e6938994f4a4bf8701_hd.jpg">
<meta property="og:image" content="https://pic2.zhimg.com/80/v2-53b695758fee38c08e5b1708f3ee0afa_hd.jpg">
<meta property="og:image" content="https://pic2.zhimg.com/80/v2-7910df5f0403079b5a2f4c3bd1472640_hd.jpg">
<meta property="og:image" content="https://pic4.zhimg.com/80/v2-5c105fb1180c8ea2de008284f5946833_hd.jpg">
<meta property="og:image" content="https://pic3.zhimg.com/80/v2-986c5b789c5d47aef369a811f4878678_hd.jpg">
<meta property="og:image" content="https://pic4.zhimg.com/80/v2-752f50c1b496ea09cfa146150a5fe65c_hd.jpg">
<meta property="og:image" content="https://pic4.zhimg.com/80/v2-4ae67f94a2ecbc090a991769ba81e43c_hd.jpg">
<meta property="og:image" content="https://pic2.zhimg.com/80/v2-03706b0555fe936436722318fd52f79c_hd.jpg">
<meta property="og:image" content="https://pic3.zhimg.com/80/v2-a66aeecfd2939bf38b9794e10520d618_hd.jpg">
<meta property="og:image" content="https://pic2.zhimg.com/80/v2-4c9f4c989b6281f1d1b9306a920e0602_hd.jpg">
<meta property="og:image" content="https://pic2.zhimg.com/80/v2-4eb0c4fdf780a89712e1ea2bc98473ca_hd.jpg">
<meta property="og:image" content="https://pic3.zhimg.com/80/v2-b50ed85f634b9fd49b7934b606e75c7b_hd.jpg">
<meta property="og:image" content="https://pic3.zhimg.com/80/v2-f61940455efe60159870ca345a334c97_hd.jpg">
<meta property="og:image" content="https://pic3.zhimg.com/80/v2-95ccd4431c8d8ff0a9272eba9c539d73_hd.jpg">
<meta property="og:image" content="https://pic3.zhimg.com/80/v2-80815da5ac27e9014310e3764262d883_hd.jpg">
<meta property="og:image" content="https://pic1.zhimg.com/80/v2-b724e02aebc60307cd03eb62b9d78da5_hd.jpg">
<meta property="og:image" content="https://pic1.zhimg.com/80/v2-c2476971d0f6b4b41c225826479401b3_hd.jpg">
<meta property="og:image" content="https://pic1.zhimg.com/80/v2-25d44e68e4f633fd4d8839f1aad6a706_hd.jpg">
<meta property="og:image" content="https://pic3.zhimg.com/80/v2-45d1af1920f35dcbe81c390f5b0819cd_hd.jpg">
<meta property="og:image" content="https://pic3.zhimg.com/80/v2-03567ded62f761c697aaa298b2fad954_hd.jpg">
<meta property="og:image" content="https://pic3.zhimg.com/80/v2-233cd7204e9bd51371dacaa573d35e94_hd.jpg">
<meta property="og:image" content="https://pic2.zhimg.com/80/v2-1e36212ecf46cdf74b9d6850f3620f15_hd.jpg">
<meta property="og:image" content="https://pic4.zhimg.com/80/v2-ee67bc11795b85749a60376158a93ce7_hd.jpg">
<meta property="og:image" content="https://pic2.zhimg.com/80/v2-c0f2742a4086afc0ca7723b6d6d69ecc_hd.jpg">
<meta property="og:image" content="https://pic2.zhimg.com/80/v2-6475a5dfb714783fd8eaafba94e300cd_hd.jpg">
<meta property="og:image" content="https://pic2.zhimg.com/80/v2-570bac7c3154aa1dd684da7790f3d432_hd.jpg">
<meta property="og:image" content="https://pic3.zhimg.com/80/v2-2754ddfe86d6d99b205a5327d67a32d5_hd.jpg">
<meta property="og:image" content="https://pic2.zhimg.com/80/v2-d11475667844660f0c436f3b0bccdad4_hd.jpg">
<meta property="og:image" content="https://pic3.zhimg.com/80/v2-23f70dd3ea13ab7f324d276cc2008d95_hd.jpg">
<meta property="og:image" content="https://pic3.zhimg.com/80/v2-0dc26291b5ab53e04aa263644fb25de4_hd.jpg">
<meta property="og:image" content="https://pic4.zhimg.com/80/v2-200767ca2c93d8dd165cd130be128aba_hd.jpg">
<meta property="og:image" content="https://pic4.zhimg.com/80/v2-915b1d306d288386640f61e8d75c2b5e_hd.jpg">
<meta property="og:image" content="https://pic1.zhimg.com/80/v2-11fb168d4145caa9ba18cfb33fab665e_hd.jpg">
<meta property="og:image" content="https://pic4.zhimg.com/80/v2-1022e90e7c26a3f650d2a77b5f35ca8e_hd.jpg">
<meta property="og:image" content="https://pic3.zhimg.com/80/v2-ade063eecbe8de6613831dc554f7bfcf_hd.jpg">
<meta property="og:image" content="https://pic2.zhimg.com/80/v2-6924a185e029a7958e7c9beb57c615fa_hd.jpg">
<meta property="og:image" content="https://pic1.zhimg.com/80/v2-a4fb4681f702314315e6351822710860_hd.jpg">
<meta property="og:image" content="https://pic4.zhimg.com/80/v2-28961ac44138618edffeef42b40d65e8_hd.jpg">
<meta property="og:image" content="https://pic4.zhimg.com/80/v2-f5c4894edba577d09861e1421df61854_hd.jpg">
<meta property="og:image" content="https://pic3.zhimg.com/80/v2-fa45001aca25e829494abc9a3c63ee20_hd.jpg">
<meta property="og:image" content="https://pic2.zhimg.com/80/v2-da316f22c219b098c7a02db9a0996c48_hd.jpg">
<meta property="og:image" content="https://pic2.zhimg.com/80/v2-bfa3f4084aaa8888b70ae957d2e6a2d1_hd.jpg">
<meta property="og:image" content="https://pic1.zhimg.com/80/v2-284fd1744f3fc70dd08de901fda97b13_hd.jpg">
<meta property="og:image" content="https://pic1.zhimg.com/80/v2-ff5b754c8df7a23667b65e5b71918843_hd.jpg">
<meta property="og:image" content="https://pic3.zhimg.com/80/v2-23ef0b29a7914c1da12851941be5245f_hd.jpg">
<meta property="og:image" content="https://pic1.zhimg.com/80/v2-c49c23d2b605cadcc894e4c82a6203df_hd.jpg">
<meta property="og:image" content="https://pic2.zhimg.com/80/v2-d230b8523f6db3b4131b7d27bd59db97_hd.jpg">
<meta property="og:image" content="https://pic3.zhimg.com/80/v2-a42a7a8428bdea6196f4d1f2e5fa4fd5_hd.jpg">
<meta property="og:image" content="https://pic2.zhimg.com/80/v2-a1989baab51ac7fceb836838e93f6c50_hd.jpg">
<meta property="og:image" content="https://pic2.zhimg.com/80/v2-f9fddfabd62ba91a9836b5d5c82e7b77_hd.jpg">
<meta property="og:image" content="https://pic3.zhimg.com/80/v2-7d0d715fb0ce8d1be8ea04ec4eb12e2e_hd.jpg">
<meta property="og:image" content="https://pic3.zhimg.com/80/v2-b3676d0e26bb8f06ba6aafb3d713c182_hd.jpg">
<meta property="og:image" content="https://pic1.zhimg.com/80/v2-eac310fc9db0ce1b8837481f32b345f0_hd.jpg">
<meta property="og:image" content="https://pic2.zhimg.com/80/v2-c630edb2eed84ab81c55cbb7aea84149_hd.jpg">
<meta property="og:image" content="https://pic4.zhimg.com/80/v2-b6a5c774a783e4a4352fd02f19fe9a8c_hd.jpg">
<meta property="og:image" content="https://pic3.zhimg.com/80/v2-fd71d973d0f4a8899368395c62293f08_hd.jpg">
<meta property="og:image" content="https://pic3.zhimg.com/80/v2-49256cda62e38f4033ff61dc6a5a9eb5_hd.jpg">
<meta property="og:image" content="https://pic2.zhimg.com/80/v2-f203413ad0071e91d54ba4baa662914e_hd.jpg">
<meta property="og:image" content="https://pic3.zhimg.com/80/v2-25ccd01314cb4edc937940a238da92a1_hd.jpg">
<meta property="og:image" content="https://pic1.zhimg.com/80/v2-6d411abcbe8dd7f6388423f82368b690_hd.jpg">
<meta property="og:image" content="https://pic1.zhimg.com/80/v2-5e8455c06422bf0722c1308c4b8fa1a8_hd.jpg">
<meta property="og:image" content="https://pic2.zhimg.com/80/v2-6a9d8b2e3db2c42168243d803138231a_hd.jpg">
<meta property="og:image" content="https://pic2.zhimg.com/80/v2-05a4031ae91989627f25233eeac6f506_hd.jpg">
<meta property="og:image" content="https://pic2.zhimg.com/80/v2-295c5b7b5c1a2b1f672265e64596ce1e_hd.jpg">
<meta property="og:image" content="https://pic3.zhimg.com/80/v2-1318b9238be523bd01194cf7bb416261_hd.jpg">
<meta property="og:image" content="https://pic3.zhimg.com/80/v2-7b236c7baa6138d39982c3a5af64c9e6_hd.jpg">
<meta property="og:image" content="https://pic2.zhimg.com/80/v2-8a4d0f0fdd1a829ec2d7c1bf9a75f428_hd.jpg">
<meta property="og:image" content="https://pic1.zhimg.com/80/v2-e34242c920fa9cba8a1c8063aa1dab02_hd.jpg">
<meta property="og:image" content="https://pic1.zhimg.com/80/v2-30587c2b5672554dc53fdc562afbe879_hd.jpg">
<meta property="og:image" content="https://pic2.zhimg.com/80/v2-c5b73ff1bd2922a3b2ecc4f0993ccaef_hd.jpg">
<meta property="og:image" content="https://pic1.zhimg.com/80/v2-fa08b00797eb9ab1ac7676f572b7ed12_hd.jpg">
<meta property="og:image" content="https://pic3.zhimg.com/80/v2-0c0966051a5d01b14fb7f1adfcfc2646_hd.jpg">
<meta property="og:image" content="https://pic3.zhimg.com/80/v2-d3e754236b6dd7f89e02eaadf26b566a_hd.jpg">
<meta property="og:image" content="https://pic4.zhimg.com/80/v2-1abe66cca352c63bd0a17d7e7c49f038_hd.jpg">
<meta property="og:image" content="https://pic2.zhimg.com/80/v2-48222058fd4ab295854bcc3d8ffba410_hd.jpg">
<meta property="og:image" content="https://pic1.zhimg.com/80/v2-7a41b90a994fe70bf463cb70b04db49d_hd.jpg">
<meta property="og:image" content="https://pic2.zhimg.com/80/v2-9a1be10821466554a2f7b171973133fe_hd.jpg">
<meta property="og:image" content="https://pic3.zhimg.com/80/v2-3600c1e18a1f822a6cf03f98d51a6a9e_hd.jpg">
<meta property="og:image" content="https://pic4.zhimg.com/80/v2-9f2b5608361b97c070b7875ce83b9e9b_hd.jpg">
<meta property="og:image" content="https://pic3.zhimg.com/80/v2-5889caed930f8e6456e0f5436f417bf0_hd.jpg">
<meta property="og:image" content="https://pic4.zhimg.com/80/v2-dd190201252b6e703f0aa27ccf3ef8d8_hd.jpg">
<meta property="og:image" content="https://pic3.zhimg.com/80/v2-550f3934b37563c402583046f2ecfa00_hd.jpg">
<meta property="og:image" content="https://pic3.zhimg.com/80/v2-8bf26ec7f1b62170664af09f1ac0ed1f_hd.jpg">
<meta property="og:image" content="https://pic3.zhimg.com/80/v2-88d412cb9e91f29e5925c7ddd661af4f_hd.jpg">
<meta property="og:image" content="https://pic2.zhimg.com/80/v2-18b5561a458d45ccd80ce1d75f84a9ea_hd.jpg">
<meta property="og:image" content="https://pic1.zhimg.com/80/v2-46c8d268396fda740c3f3e0aa96ee0c7_hd.jpg">
<meta property="og:image" content="https://pic1.zhimg.com/80/v2-8a74573c377e77af4ac699ac8ab1d07d_hd.jpg">
<meta property="og:image" content="https://pic2.zhimg.com/80/v2-0ac8d99ee4bed79a89b5f5abcd0bf161_hd.jpg">
<meta property="og:image" content="https://pic3.zhimg.com/80/v2-ba89152565892ede64bd0374023bf980_hd.jpg">
<meta property="og:image" content="https://pic2.zhimg.com/80/v2-3fed5e7268b4d3d86c908828fafba138_hd.jpg">
<meta property="og:image" content="https://pic4.zhimg.com/80/v2-80ed14890b57bc617c6493cbc8fff50c_hd.jpg">
<meta property="og:image" content="https://pic2.zhimg.com/80/v2-f4ee5c76f8143f72924da221976adf62_hd.jpg">
<meta property="og:image" content="https://pic3.zhimg.com/80/v2-5fc741b1c3808d9446f8e2da9019b6fc_hd.jpg">
<meta property="og:image" content="https://pic3.zhimg.com/80/v2-8a7d63e43590a4859faaed76a4d6dabd_hd.jpg">
<meta property="og:image" content="https://pic4.zhimg.com/80/v2-977af27c7a944bdbddd261133b670150_hd.jpg">
<meta property="og:image" content="https://pic3.zhimg.com/80/v2-66aa5c89da0590b8df1fb1aaaa27bc05_hd.jpg">
<meta property="og:image" content="https://pic3.zhimg.com/80/v2-7d38ba75d236d8825de65263e38bbabc_hd.jpg">
<meta property="og:image" content="https://pic4.zhimg.com/80/v2-c8f204087140c869503ab1c64f5b764d_hd.jpg">
<meta property="og:image" content="https://pic1.zhimg.com/80/v2-5fd801e317ef34c26e1b0c1872260126_hd.jpg">
<meta property="og:image" content="https://pic4.zhimg.com/80/v2-f354d67e2bf8ac1b14f8fe9078524245_hd.jpg">
<meta property="og:image" content="https://pic3.zhimg.com/80/v2-16f09c835b8b486e21d3eed601c3ad84_hd.jpg">
<meta property="og:image" content="https://pic3.zhimg.com/80/v2-1cbe14644fb39c93745daea2f5e56a06_hd.jpg">
<meta property="og:image" content="https://pic1.zhimg.com/80/v2-e50e0b8bdd127530871188188ea7c8bc_hd.jpg">
<meta property="og:image" content="https://pic4.zhimg.com/80/v2-099c4a8bac808e3e6d7ba63258d10615_hd.jpg">
<meta property="og:updated_time" content="2018-02-16T03:03:58.711Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="必备神器之seaborn">
<meta name="twitter:description" content="python绘图软件seaborn的常用介绍 官方文档： seaborn官方文档 以下是常用功能  import语句1import searborn as sns">
<meta name="twitter:image" content="https://pic1.zhimg.com/80/v2-96e264d6b87333b0fb5db977588998f7_hd.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":true,"onmobile":true},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2018/02/08/必备神器之seaborn/"/>





  <title>必备神器之seaborn | Kuiyuan's Blog</title>
  




<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-112777962-1', 'auto');
  ga('send', 'pageview');
</script>


  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?781a1b13eabd27493228f44824af7329";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>
    <a href="https://github.com/KuiyuanZhang" class="github-corner" aria-label="View source on Github"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Kuiyuan's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Stay hungry. Stay foolish.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-top">
          <a href="/top/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-signal"></i> <br />
            
            top
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-futbol-o"></i> <br />
            
            关于
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/02/08/必备神器之seaborn/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="KuiyuanZhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://avatars3.githubusercontent.com/u/17525031?s=400&u=fab06329bc1d10873fe82aa4c050440ace03202a&v=4">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Kuiyuan's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">必备神器之seaborn</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-08T23:47:40+08:00">
                2018-02-08
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/工具/" itemprop="url" rel="index">
                    <span itemprop="name">工具</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i> 浏览
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>次
            </span>
          

          
            <div class="post-wordcount">
              
                
                  <span class="post-meta-divider">|</span>
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  16,718 字
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  66 分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <blockquote>
<p>python绘图软件seaborn的常用介绍</p>
<p>官方文档： <a href="http://seaborn.pydata.org/tutorial.html" target="_blank" rel="noopener">seaborn官方文档</a></p>
<p>以下是常用功能</p>
</blockquote>
<h4 id="import语句"><a href="#import语句" class="headerlink" title="import语句"></a>import语句</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> searborn <span class="keyword">as</span> sns</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="第一章-艺术化的图表控制"><a href="#第一章-艺术化的图表控制" class="headerlink" title="第一章 艺术化的图表控制"></a>第一章 艺术化的图表控制</h2><p>Matplotlib无疑是高度可定制的，但快速实施出吸引人的细节就变得有些复杂。Seaborn作为一个带着定制主题和高级界面控制的Matplotlib扩展包，能让绘图变得更轻松，本部分主要介绍seaborn是如何对matplotlib输出的外观进行控制的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">%matplotlib inline </span><br><span class="line"><span class="comment">#jupyter notebook 中的魔法函数，如果不是使用该软件请使用plt.show()用于显示图像</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib <span class="keyword">as</span> mpl</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">np.random.seed(sum(map(ord,<span class="string">"aesthetics"</span>)))  <span class="comment"># 定义种子</span></span><br></pre></td></tr></table></figure>
<p>定义一个含偏移的正弦图像，来比较传统的matplotlib和seaborn的不同：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sinplot</span><span class="params">(flip=<span class="number">1</span>)</span>:</span></span><br><span class="line">    x = np.linspace(<span class="number">0</span>,<span class="number">14</span>,<span class="number">100</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">7</span>):</span><br><span class="line">        plt.plot(x,np.sin(x+i*<span class="number">.5</span>)*(<span class="number">7</span>-i)*flip)</span><br></pre></td></tr></table></figure>
<p>使用matplotlib默认设置的图形效果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sinplot()</span><br></pre></td></tr></table></figure>
<p><img src="https://pic1.zhimg.com/80/v2-96e264d6b87333b0fb5db977588998f7_hd.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import seaborn as sns</span><br><span class="line">sinplot()</span><br></pre></td></tr></table></figure>
<p><img src="https://pic2.zhimg.com/80/v2-d0e5a4d24a0bcbe01d9c2fd995ae6099_hd.jpg" alt="img"></p>
<p>seaborn默认的灰色网格底色灵感来源于matplotlib却更加柔和。大多数情况下，图应优于表。seaborn的默认灰色网格底色避免了刺目的干扰，对于多个方面的图形尤其有用，是一些更复杂的工具的核心。</p>
<p>Seaborn将matplotlib参数分成两个独立的组。第一组设定了美学风格，第二组则是不同的度量元素，这样就可以很容易地添加到代码当中了。</p>
<p>操作这些参数的接口是两对函数。为了控制样式，使用axesstyle()和setstyle()函数。为了扩展绘图，请使用plotting_context()和set_context()函数。在这两种情况下，第一个函数返回一个参数字典，第二个函数则设置matplotlib默认属性。</p>
<h2 id="样式控制：axes-style-and-set-style"><a href="#样式控制：axes-style-and-set-style" class="headerlink" title="样式控制：axes_style() and set_style()"></a>样式控制：axes_style() and set_style()</h2><p>有5个seaborn的主题，适用于不同的应用和人群偏好：</p>
<ul>
<li>darkgrid 黑色网格（默认）</li>
<li>whitegrid 白色网格</li>
<li>dark 黑色背景</li>
<li>white 白色背景</li>
<li>ticks 应该是四周都有刻度线的白背景？</li>
</ul>
<p>网格能够帮助我们查找图表中的定量信息，而灰色网格主题中的白线能避免影响数据的表现，白色网格主题则类似的，当然更适合表达“重数据元素”（heavy data elements不理解）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sns.set_style(&quot;whitegrid&quot;)</span><br><span class="line">data = np.random.normal(size=(20, 6)) + np.arange(6) / 2</span><br><span class="line">sns.boxplot(data=data);</span><br></pre></td></tr></table></figure>
<p><img src="https://pic4.zhimg.com/80/v2-436b148a808465534752b0e2f0cd127e_hd.jpg" alt="img"></p>
<p>对于许多场景，(特别是对于像对话这样的设置，您主要想使用图形来提供数据模式的印象)，网格就不那么必要了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sns.set_style(&quot;dark&quot;)</span><br><span class="line">sinplot()</span><br></pre></td></tr></table></figure>
<p><img src="https://pic1.zhimg.com/80/v2-c180b44ec34056361c705928b083715a_hd.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sns.set_style(&quot;white&quot;)</span><br><span class="line">sinplot()</span><br></pre></td></tr></table></figure>
<p><img src="https://pic2.zhimg.com/80/v2-12960e1a69df3f22bde993970a446655_hd.jpg" alt="img"></p>
<p>有时你可能想要给情节增加一点额外的结构，这就是ticks参数的用途:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sns.set_style(&quot;ticks&quot;)</span><br><span class="line">sinplot()</span><br><span class="line"># 官方的例子在上方/右方也拥有刻度线，而验证时却没有（是jupyter notebook的原因？）</span><br></pre></td></tr></table></figure>
<p><img src="https://pic2.zhimg.com/80/v2-050c042daedc78711c5d1e34c1d01cba_hd.jpg" alt="img"></p>
<blockquote>
<p>这里是官方运行的结果，供参考：</p>
</blockquote>
<p><img src="https://pic2.zhimg.com/80/v2-6ff1e678229d4f1068153b36c7e3fc9e_hd.jpg" alt="img"></p>
<p>特别的可以通过sns.axes_style(style=None, rc=None) 返回一个sns.set_style()可传的参数的字典</p>
<p>通过类似sns.set_style(“ticks”, {“xtick.major.size”: 8, “ytick.major.size”: 8})的方式写入更具体的配置样式。</p>
<p>关于sns.axes_style()下面会有说明和运行结果</p>
<h2 id="用despine-进行边框控制"><a href="#用despine-进行边框控制" class="headerlink" title="用despine()进行边框控制"></a>用despine()进行边框控制</h2><p>white和ticks参数的样式，都可以删除上方和右方坐标轴上不需要的边框，这在matplotlib中是无法通过参数实现的，却可以在seaborn中通过despine()函数轻松移除他们。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sns.set_style(&quot;white&quot;)</span><br><span class="line">sinplot() # 默认无参数状态，就是删除上方和右方的边框</span><br><span class="line">sns.despine()</span><br></pre></td></tr></table></figure>
<p><img src="https://pic3.zhimg.com/80/v2-e3b1dd4ffa6601e8b9955b12b2550d16_hd.jpg" alt="img"></p>
<p>一些图的边框可以通过数据移位，当然调用despine()也能做同样的事。当边框没有覆盖整个数据轴的范围的时候，trim参数会限制留存的边框范围。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f, ax = plt.subplots()</span><br><span class="line">sns.violinplot(data=data)</span><br><span class="line">sns.despine(offset=10, trim=True); # offset 两坐标轴离开距离；</span><br></pre></td></tr></table></figure>
<p><img src="https://pic1.zhimg.com/80/v2-11a06ec6f0fbb3e18f6db83f7a288c63_hd.jpg" alt="img"></p>
<p>你也可以通过往despine()中添加参数去控制边框</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sns.set_style(&quot;whitegrid&quot;)</span><br><span class="line">sns.boxplot(data=data, palette=&quot;deep&quot;)</span><br><span class="line">sns.despine(left=True) # 删除左边边框</span><br><span class="line">st = sns.axes_style(&quot;darkgrid&quot;)</span><br></pre></td></tr></table></figure>
<p><img src="https://pic1.zhimg.com/80/v2-a36d19c549a4ea5a6bca0743ef7fec8c_hd.jpg" alt="img"></p>
<p>despine(fig=None, ax=None, top=True, right=True, left=False, bottom=False, offset=None, trim=False)</p>
<p>从plot()函数中移除顶部或右边的边框</p>
<h2 id="临时设定图形样式"><a href="#临时设定图形样式" class="headerlink" title="临时设定图形样式"></a>临时设定图形样式</h2><p>虽然来回切换非常容易，但sns也允许用with语句中套用axes_style()达到临时设置参数的效果（仅对with块内的绘图函数起作用）。这也允许创建不同风格的坐标轴。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">with sns.axes_style(&quot;darkgrid&quot;):</span><br><span class="line">    plt.subplot(211)</span><br><span class="line">    sinplot()</span><br><span class="line">plt.subplot(212)</span><br><span class="line">sinplot(-1)</span><br></pre></td></tr></table></figure>
<p><img src="https://pic4.zhimg.com/80/v2-074042f10a2a586a7c89b70bdde41f0e_hd.jpg" alt="img"></p>
<h2 id="seaborn样式中最重要的元素"><a href="#seaborn样式中最重要的元素" class="headerlink" title="seaborn样式中最重要的元素"></a>seaborn样式中最重要的元素</h2><p>如果您想要定制seanborn的样式，可以将参数字典传递给axes_style()和set_style()的rc参数。注意，只能通过该方法覆盖样式定义的一部分参数。(然而，更高层次的set()函数接受任何matplotlib参数的字典)。</p>
<p>如果您想要查看包含哪些参数，您可以只调用该函数而不带参数，这将返回当前设置的字典:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">sns.axes_style()</span><br><span class="line"></span><br><span class="line">&#123;&apos;axes.axisbelow&apos;: True,</span><br><span class="line"> &apos;axes.edgecolor&apos;: &apos;white&apos;,</span><br><span class="line"> &apos;axes.facecolor&apos;: &apos;#EAEAF2&apos;,</span><br><span class="line"> &apos;axes.grid&apos;: True,</span><br><span class="line"> &apos;axes.labelcolor&apos;: &apos;.15&apos;,</span><br><span class="line"> &apos;axes.linewidth&apos;: 0.0,</span><br><span class="line"> &apos;figure.facecolor&apos;: &apos;white&apos;,</span><br><span class="line"> &apos;font.family&apos;: [&apos;sans-serif&apos;],</span><br><span class="line"> &apos;font.sans-serif&apos;: [&apos;Arial&apos;,</span><br><span class="line">  &apos;Liberation Sans&apos;,</span><br><span class="line">  &apos;Bitstream Vera Sans&apos;,</span><br><span class="line">  &apos;sans-serif&apos;],</span><br><span class="line"> &apos;grid.color&apos;: &apos;white&apos;,</span><br><span class="line"> &apos;grid.linestyle&apos;: &apos;-&apos;,</span><br><span class="line"> &apos;image.cmap&apos;: &apos;Greys&apos;,</span><br><span class="line"> &apos;legend.frameon&apos;: False,</span><br><span class="line"> &apos;legend.numpoints&apos;: 1,</span><br><span class="line"> &apos;legend.scatterpoints&apos;: 1,</span><br><span class="line"> &apos;lines.solid_capstyle&apos;: &apos;round&apos;,</span><br><span class="line"> &apos;text.color&apos;: &apos;.15&apos;,</span><br><span class="line"> &apos;xtick.color&apos;: &apos;.15&apos;,</span><br><span class="line"> &apos;xtick.direction&apos;: &apos;out&apos;,</span><br><span class="line"> &apos;xtick.major.size&apos;: 0.0,</span><br><span class="line"> &apos;xtick.minor.size&apos;: 0.0,</span><br><span class="line"> &apos;ytick.color&apos;: &apos;.15&apos;,</span><br><span class="line"> &apos;ytick.direction&apos;: &apos;out&apos;,</span><br><span class="line"> &apos;ytick.major.size&apos;: 0.0,</span><br><span class="line"> &apos;ytick.minor.size&apos;: 0.0&#125;</span><br></pre></td></tr></table></figure>
<p>或许，你可以试试不同种类的参数效果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sns.set_style(&quot;darkgrid&quot;, &#123;&quot;axes.facecolor&quot;: &quot;.9&quot;&#125;)</span><br><span class="line">sinplot()</span><br></pre></td></tr></table></figure>
<p><img src="https://pic2.zhimg.com/80/v2-657ac986e339294193453407806f9fca_hd.jpg" alt="img"></p>
<h2 id="通过-plotting-context-和-set-context-调整绘图元素"><a href="#通过-plotting-context-和-set-context-调整绘图元素" class="headerlink" title="通过 plotting_context() 和 set_context() 调整绘图元素"></a>通过 plotting_context() 和 set_context() 调整绘图元素</h2><p>另一组参数控制绘图元素的规模，这应该让您使用相同的代码来制作适合在较大或较小的情节适当的场景中使用的情节。</p>
<p>首先，可以通过sns.set()重置参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.set()</span><br></pre></td></tr></table></figure>
<p>四种预设，按相对尺寸的顺序(线条越来越粗)，分别是paper，notebook, talk, and poster。notebook的样式是默认的，上面的绘图都是使用默认的notebook预设。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sns.set_context(&quot;paper&quot;)</span><br><span class="line">plt.figure(figsize=(8,6))</span><br><span class="line">sinplot()</span><br></pre></td></tr></table></figure>
<p><img src="https://pic2.zhimg.com/80/v2-f9d617e2bdd21320b07a9dbe2ba7098f_hd.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># default 默认设置</span><br><span class="line">sns.set_context(&quot;notebook&quot;)</span><br><span class="line">plt.figure(figsize=(8,6))</span><br><span class="line">sinplot()</span><br></pre></td></tr></table></figure>
<p><img src="https://pic3.zhimg.com/80/v2-89d18849932e697a973ee04d8216af1d_hd.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sns.set_context(&quot;talk&quot;)</span><br><span class="line">plt.figure(figsize=(8,6))</span><br><span class="line">sinplot()</span><br></pre></td></tr></table></figure>
<p><img src="https://pic4.zhimg.com/80/v2-4098205f7671ffc7dd72c54d11e8a27e_hd.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sns.set_context(&quot;poster&quot;)</span><br><span class="line">plt.figure(figsize=(8,6))</span><br><span class="line">sinplot()</span><br></pre></td></tr></table></figure>
<p><img src="https://pic4.zhimg.com/80/v2-dd92bb2302af238bd4887185749ba278_hd.jpg" alt="img"></p>
<p>通过观察各种样式的结果，你应当可以了解context函数</p>
<p>类似的，还可以使用其中一个名称来调用set_context()来设置参数，您可以通过提供参数值的字典来覆盖参数。</p>
<p>通过更改context还可以独立地扩展字体元素的大小。(这个选项也可以通过顶级set()函数获得）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sns.set_context(&quot;notebook&quot;, font_scale=1.5, rc=&#123;&quot;lines.linewidth&quot;: 2.5&#125;)</span><br><span class="line">sinplot()</span><br></pre></td></tr></table></figure>
<p><img src="https://pic3.zhimg.com/80/v2-207352f0a3a968fdb8ab6f33d5b1b9e4_hd.jpg" alt="img"></p>
<p>类似地(尽管它可能用处不大)，也可以使用with嵌套语句进行临时的设置。</p>
<p>样式和上下文都可以用set()函数快速地进行配置。这个函数还设置了默认的颜色选项，在下一节将详细介绍这一功能。</p>
<hr>
<p>颜色显然比图形风格的其他方面都更加重要，因为颜色使用得当就可以有效显示或隐藏数据中的特征。有许多的好资源都可以了解关于在可视化中使用颜色的技巧，推荐<a href="http://link.zhihu.com/?target=https%3A//earthobservatory.nasa.gov/blogs/elegantfigures/2013/08/05/subtleties-of-color-part-1-of-6/" target="_blank" rel="noopener">Rob Simmon的《series of blog posts》</a>和这篇进阶的<a href="http://link.zhihu.com/?target=https%3A//cfwebprod.sandia.gov/cfdocs/CompResearch/docs/ColorMapsExpanded.pdf" target="_blank" rel="noopener">技术文章</a>,<a href="http://link.zhihu.com/?target=http%3A//matplotlib.org/users/colormaps.html" target="_blank" rel="noopener">matplotlib文档</a>现在也有一个很好的教程，说明了如何在内置色彩映射中构建的一些感知特性。</p>
<p>Seaborn让你更容易选择和使用那些适合你数据和视觉的颜色。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">%matplotlib inline</span><br><span class="line">import numpy as np</span><br><span class="line">import seaborn as sns</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">sns.set(rc=&#123;&quot;figure.figsize&quot;: (6, 6)&#125;)</span><br><span class="line">np.random.seed(sum(map(ord, &quot;palettes&quot;)))</span><br></pre></td></tr></table></figure>
<h2 id="通过color-palette-创建调色板"><a href="#通过color-palette-创建调色板" class="headerlink" title="通过color_palette()创建调色板"></a>通过color_palette()创建调色板</h2><p>最重要的直接设置调色板的函数就是color_palette()。这个函数提供了许多（并非所有）在seaborn内生成颜色的方式。并且它可以用于任何函数内部的palette参数设置（在某些情况下当需要多种颜色时也可以传入到color参数）</p>
<p>color_palette()允许任意的seaborn调色板或matplotlib的颜色映射（除了jet，你应该完全不使用它）。它还可以使用任何有效的matplotlib格式指定的颜色列表(RGB元组、十六进制颜色代码或HTML颜色名称)。返回值总是一个RGB元组的列表。</p>
<p>最后，直接调用没有传入参数的color_palette()将返回默认的颜色循环。</p>
<p>对应的函数set_palette()接受相同的参数，并为所有图设置默认的颜色循环。你也可以在with块中使用color_palette()来实现临时的更改调色板配置（下面有详细例子）。</p>
<p>通常在不知道数据的具体特征的情况下不可能知道什么类型的调色板或颜色映射对于一组数据来说是最好的。因此，我们将用三种不同类型的调色板：分类色板、连续色板和离散色板，来区分和使用color_palette()函数。</p>
<h2 id="分类色板"><a href="#分类色板" class="headerlink" title="分类色板"></a>分类色板</h2><p>分类色板（定性）是在区分没有固定顺序的数据时最好的选择。</p>
<p>在导入seaborn库后，默认的颜色循环被更改为一组六种颜色。虽然这些颜色可能会让你想起matplotlib的标准颜色循环，但他们无疑更赏心悦目一些。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">current_palette = sns.color_palette()</span><br><span class="line">sns.palplot(current_palette)</span><br></pre></td></tr></table></figure>
<p><img src="https://pic3.zhimg.com/80/v2-5ad4013ce278d06d9bc1c633b5e740d9_hd.jpg" alt="img"></p>
<p>默认颜色主题共有六种不同的变化分别是：deep, muted, pastel, bright, dark, 和 colorblind。类似下面的方式直接传入即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">current_palette = sns.color_palette(&quot;dark&quot;) # 直接传入对应的参数即可变化</span><br><span class="line">sns.palplot(current_palette)</span><br></pre></td></tr></table></figure>
<p><img src="https://pic4.zhimg.com/80/v2-ba711a8887d5d3d217123c0796741c1b_hd.jpg" alt="img"></p>
<h2 id="使用圆形颜色系统"><a href="#使用圆形颜色系统" class="headerlink" title="使用圆形颜色系统"></a>使用圆形颜色系统</h2><p>当你有六个以上的分类要区分时，最简单的方法就是在一个圆形的颜色空间中画出均匀间隔的颜色(这样的色调会保持亮度和饱和度不变)。这是大多数的当他们需要使用比当前默认颜色循环中设置的颜色更多时的默认方案。</p>
<p>最常用的方法是使用hls的颜色空间，这是RGB值的一个简单转换。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.palplot(sns.color_palette(&quot;hls&quot;, 8))</span><br></pre></td></tr></table></figure>
<p><img src="https://pic2.zhimg.com/80/v2-f85e33b615f3f20cd930d8722f9feb26_hd.jpg" alt="img"></p>
<p>当然，也可以使用hls_palette()函数来控制颜色的亮度和饱和。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sns.palplot(sns.hls_palette(8, l=.3, s=.8))</span><br><span class="line"># l-亮度 lightness / s-饱和 saturation</span><br></pre></td></tr></table></figure>
<p><img src="https://pic7.zhimg.com/80/v2-1bed7a99683ef5c944c2fe5a13d703ff_hd.jpg" alt="img"></p>
<p>由于人类视觉系统的工作方式，会导致在RGB度量上强度一致的颜色在视觉中并不平衡。比如，我们黄色和绿色是相对较亮的颜色，而蓝色则相对较暗，使得这可能会成为与hls系统一致的一个问题。</p>
<p>为了解决这一问题，seaborn为husl系统提供了一个接口，这也使得选择均匀间隔的色彩变得更加容易，同时保持亮度和饱和度更加一致。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.palplot(sns.color_palette(&quot;husl&quot;, 8))</span><br></pre></td></tr></table></figure>
<p><img src="https://pic4.zhimg.com/80/v2-24fcd5ec6caeb4b685d66cdbe86d41fe_hd.jpg" alt="img"></p>
<p>使用分类颜色调色板</p>
<p>另一种视觉上令人愉悦的分类调色板来自于Color Brewer工具(它也有连续调色板和离散调色板，我们将在下面的图中看到)。这些也存在于matplotlib颜色映射中，但是它们没有得到适当的处理。在这里，当你要求一个定性颜色的调色板时，你总是会得到离散的颜色，但这意味着在某一点它们会开始循环。</p>
<p>Color Brewer工具的一个很好的特点是，它提供了一些关于调色板是色盲安全的指导。有各种各样的<a href="http://link.zhihu.com/?target=http%3A//en.wikipedia.org/wiki/Color_blindness" target="_blank" rel="noopener">适合色盲的颜色</a>，但是最常见的变异导致很难区分红色和绿色。一般来说，避免使用红色和绿色来表示颜色以区分元素是一个不错的主意。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.palplot(sns.color_palette(&quot;Paired&quot;))</span><br></pre></td></tr></table></figure>
<p><img src="https://pic3.zhimg.com/80/v2-3a8badc7c6ddf7f470ba89687e6835f4_hd.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.palplot(sns.color_palette(&quot;Set2&quot;, 10))</span><br></pre></td></tr></table></figure>
<p><img src="https://pic1.zhimg.com/80/v2-906e0e32ab89e6301fa0a19a24e98ec5_hd.jpg" alt="img"></p>
<p>为了帮助您从Color Brewer工具中选择调色板，这里有choose_colorbrewer_palette()函数。这个函数必须在IPython notebook中使用，它将启动一个交互式小部件，让您浏览各种选项并调整参数。</p>
<p>当然，您可能只想使用一组您特别喜欢的颜色。因为color_palette()接受一个颜色列表，这很容易做到。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">flatui = [&quot;#9b59b6&quot;, &quot;#3498db&quot;, &quot;#95a5a6&quot;, &quot;#e74c3c&quot;, &quot;#34495e&quot;, &quot;#2ecc71&quot;]</span><br><span class="line">sns.palplot(sns.color_palette(flatui))</span><br><span class="line">sns.choose_colorbrewer_palette(&quot;sequential&quot;)</span><br><span class="line"># data_type: &#123;‘sequential’, ‘diverging’, ‘qualitative’&#125;</span><br><span class="line">sns.choose_colorbrewer_palette(&quot;sequential&quot;,as_cmap=True)</span><br><span class="line"># as_cmap参数用来更改显示的颜色范围是离散的还是连续的</span><br></pre></td></tr></table></figure>
<p><img src="https://pic1.zhimg.com/80/v2-851229aebdd9a4256c954f62fafae005_hd.jpg" alt="img"></p>
<p><img src="https://pic3.zhimg.com/80/v2-b9eecc1da38590eea5e0cf978f509ca8_hd.jpg" alt="img"></p>
<p><img src="https://pic1.zhimg.com/80/v2-906536f92686620044e429423a774ffb_hd.jpg" alt="img"></p>
<p>使用xkcd颜色来命名颜色</p>
<p>xkcd包含了一套众包努力的针对随机RGB色的命名。产生了954个可以随时通过xdcd_rgb字典中调用的命名颜色。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plt.plot([0, 1], [0, 1], sns.xkcd_rgb[&quot;pale red&quot;], lw=3)</span><br><span class="line">plt.plot([0, 1], [0, 2], sns.xkcd_rgb[&quot;medium green&quot;], lw=3)</span><br><span class="line">plt.plot([0, 1], [0, 3], sns.xkcd_rgb[&quot;denim blue&quot;], lw=3);</span><br></pre></td></tr></table></figure>
<p><img src="https://pic1.zhimg.com/80/v2-e5db2fc83e78b3090d4d9db3f42e2891_hd.jpg" alt="img"></p>
<p>如果你想花一些时间挑选颜色，或许这种<a href="http://link.zhihu.com/?target=http%3A//www.luminoso.com/colors/" target="_blank" rel="noopener">交互式的可视化</a>（官方链接失效）是非常有帮助的。除了将单一颜色从xkcd_rgb字典中取出，也可以通过名称列表传入xkcd_palette()函数中取得颜色组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">colors = [&quot;windows blue&quot;, &quot;amber&quot;, &quot;greyish&quot;, &quot;faded green&quot;, &quot;dusty purple&quot;]</span><br><span class="line">sns.palplot(sns.xkcd_palette(colors))</span><br></pre></td></tr></table></figure>
<p><img src="https://pic1.zhimg.com/80/v2-a4d334b52b4ce7fea79631b57b6ec23e_hd.jpg" alt="img"></p>
<p>连续色板</p>
<p>调色板中第二大类称为“顺序”。这种颜色映射对应的是从相对低价值（无意义）数据到高价值（有意义）的数据范围。虽然有时候你会需要一个连续的离散颜色调色板，用他们像kdeplot()或者corrplot()功能映射更加常见（以及可能类似的matplotlib功能）。</p>
<p>非常可能的是见到jet色彩映射（或其他采用调色板）在这种情况下使用，因为色彩范围提供有关数据的附加信息。然而，打的色调变化中往往会引入不连续性中不存在的数据和视觉系统不能自然的通过“彩虹色”定量产生“高”、“低”之分。其结果是，这样的可视化更像是一个谜题，模糊了数据中的信息而并非揭示这种信息。事实上，jet调色板可能非常糟糕，因为最亮的颜色，黄色和青色用于显示中间数值，这就导致强调了一些没有意义的数据而忽视了端点的数据。</p>
<p>所以对于连续的数据，最好是使用那些在色调上相对细微变化的调色板，同时在亮度和饱和度上有很大的变化。这种方法将自然地吸引数据中相对重要的部分</p>
<p>Color Brewer的字典中就有一组很好的调色板。它们是以在调色板中的主导颜色(或颜色)命名的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.palplot(sns.color_palette(&quot;Blues&quot;))</span><br></pre></td></tr></table></figure>
<p><img src="https://pic3.zhimg.com/80/v2-f7df28002ee1abbd27d8ffa2f9b5e906_hd.jpg" alt="img"></p>
<p>就像在matplotlib中一样，如果您想要翻转渐变，您可以在面板名称中添加一个_r后缀。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.palplot(sns.color_palette(&quot;BuGn_r&quot;))</span><br></pre></td></tr></table></figure>
<p><img src="https://pic3.zhimg.com/80/v2-5ffe4b697daf3596acaceb42b592f542_hd.jpg" alt="img"></p>
<p>seaborn还增加了一个允许创建没有动态范围的”dark”面板。如果你想按顺序画线或点，这可能是有用的，因为颜色鲜艳的线可能很难区分。</p>
<p>类似的，这种暗处理的颜色，需要在面板名称中添加一个_d后缀</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.palplot(sns.color_palette(&quot;GnBu_d&quot;))</span><br></pre></td></tr></table></figure>
<p><img src="https://pic1.zhimg.com/80/v2-e339949a2efaeef4c4384bf5e7534ae4_hd.jpg" alt="img"></p>
<p>牢记，你可能想使用choose_colorbrewer_palette()函数取绘制各种不同的选项。如果你想返回一个变量当做颜色映射传入seaborn或matplotlib的函数中，可以设置as_cmap参数为True。</p>
<h2 id="cubehelix-palette-函数的连续调色板"><a href="#cubehelix-palette-函数的连续调色板" class="headerlink" title="cubehelix_palette()函数的连续调色板"></a>cubehelix_palette()函数的连续调色板</h2><p><a href="http://link.zhihu.com/?target=http%3A//www.mrao.cam.ac.uk/%7Edag/CUBEHELIX/" target="_blank" rel="noopener">cubehelix</a>调色板系统具有线性增加或降低亮度和色调变化顺序的调色板。这意味着在你的映射信息会在保存为黑色和白色（为印刷）时或被一个色盲的人浏览时可以得以保留。</p>
<p>Matplotlib拥有一个默认的内置cubehelix版本可供创建:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.palplot(sns.color_palette(&quot;cubehelix&quot;, 8))</span><br></pre></td></tr></table></figure>
<p><img src="https://pic2.zhimg.com/80/v2-8c0cb56d05cc65498bffcb87164d055e_hd.jpg" alt="img"></p>
<p>seaborn为cubehelix系统添加一个接口使得其可以在各种变化中都保持良好的亮度线性梯度。</p>
<p>通过seaborn的cubehelix_palette()函数返回的调色板与matplotlib默认值稍有所不同，它不会在色轮周围旋转或覆盖更广的强度范围。seaborn还改变了排序使得更重要的值显得更暗：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.palplot(sns.cubehelix_palette(8))</span><br></pre></td></tr></table></figure>
<p><img src="https://pic4.zhimg.com/80/v2-66b181cb9d4fe29d58aaaaacd0fdacaf_hd.jpg" alt="img"></p>
<p>其他cubehelix_palette()的参数主要调整色板的视觉。两个重要的选择是：start(值的范围为03）和rot，还有rot的次数（-11之间的任意值）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.palplot(sns.cubehelix_palette(8, start=.5, rot=-.75))</span><br></pre></td></tr></table></figure>
<p><img src="https://pic1.zhimg.com/80/v2-89c5b6e8210e426717b1c3dafc39e4b7_hd.jpg" alt="img"></p>
<p>你也可以控制断点的亮度和甚至对调结果顺序</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.palplot(sns.cubehelix_palette(8, start=2, rot=0, dark=0, light=.95, reverse=True))</span><br></pre></td></tr></table></figure>
<p><img src="https://pic4.zhimg.com/80/v2-8a7dec638c0844e117a25c889e7324fc_hd.jpg" alt="img"></p>
<p>默认情况下你只会得到一些与seaborn调色板相似的颜色的列表，但你也可以让调色板返回一个可以用as_cmap=True传入seaborn或matplotlib函数的颜色映射对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x, y = np.random.multivariate_normal([0, 0], [[1, -.5], [-.5, 1]], size=300).T</span><br><span class="line">cmap = sns.cubehelix_palette(light=1, as_cmap=True)</span><br><span class="line">sns.kdeplot(x, y, cmap=cmap, shade=True);</span><br></pre></td></tr></table></figure>
<p><img src="https://pic2.zhimg.com/80/v2-ef09b91ef4b313522a7915f2b41a5fdd_hd.jpg" alt="img"></p>
<p>类似的，也可以在notebook中使用choose_cubehelix_palette()函数启动一个互助程序来帮助选择更适合的调色板或颜色映射。如果想让函数返回一个类似hexbin的颜色映射而非一个列表则需要传入as_cmap=True。</p>
<h2 id="使用light-palette-和dark-palette-调用定制连续调色板"><a href="#使用light-palette-和dark-palette-调用定制连续调色板" class="headerlink" title="使用light_palette() 和dark_palette()调用定制连续调色板"></a>使用light_palette() 和dark_palette()调用定制连续调色板</h2><p>这里还有一个更简单的连续调色板的使用方式，就是调用light_palette() 和dark_palette()，这与一个单一颜色和种子产生的从亮到暗的饱和度的调色板。这些函数还伴有choose_light_palette() and choose_dark_palette()函数，这些函数启动了交互式小部件来创建这些调色板。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sns.palplot(sns.light_palette(&quot;green&quot;))</span><br><span class="line">sns.palplot(sns.dark_palette(&quot;purple&quot;))</span><br></pre></td></tr></table></figure>
<p><img src="https://pic1.zhimg.com/80/v2-b9c0c3be1f396f59d225a31eb1fd2a0d_hd.jpg" alt="img"></p>
<p><img src="https://pic1.zhimg.com/80/v2-8bf2abd6be5eb2703826fa778d73584b_hd.jpg" alt="img"></p>
<p>这些调色板结果也可以颠倒</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.palplot(sns.light_palette(&quot;navy&quot;, reverse=True))</span><br></pre></td></tr></table></figure>
<p><img src="https://pic2.zhimg.com/80/v2-2182193b71a409e7167973482029a86c_hd.jpg" alt="img"></p>
<p>当然也可以创建一个颜色映射对象取代颜色列表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pal = sns.dark_palette(&quot;palegreen&quot;, as_cmap=True)</span><br><span class="line">sns.kdeplot(x, y, cmap=pal);</span><br></pre></td></tr></table></figure>
<p><img src="https://pic2.zhimg.com/80/v2-d6aaa2f056c643055fc4ced364c2c910_hd.jpg" alt="img"></p>
<p>默认情况下，任何有效的matplotlib颜色可以传递给input参数。也可以在hls或husl空间中提供默认的rgb元组，您还可以使用任何有效的xkcd颜色的种子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sns.palplot(sns.light_palette((210, 90, 60), input=&quot;husl&quot;))</span><br><span class="line">sns.palplot(sns.dark_palette(&quot;muted purple&quot;, input=&quot;xkcd&quot;))</span><br></pre></td></tr></table></figure>
<p><img src="https://pic2.zhimg.com/80/v2-66a8b888f654677f08317e3a40af068d_hd.jpg" alt="img"></p>
<p><img src="https://pic3.zhimg.com/80/v2-06b20374bc180f9e18dd80c73f825923_hd.jpg" alt="img"></p>
<p>需要注意的是，为默认的input空间提供交互的组件是husl，这与函数自身默认的并不同，但这在背景下却是更有用的。</p>
<h2 id="离散色板"><a href="#离散色板" class="headerlink" title="离散色板"></a>离散色板</h2><p>调色板中的第三类被称为“离散”。用于可能无论大的低的值和大的高的值都非常重要的数据。数据中通常有一个定义良好的中点。例如，如果你正在绘制温度变化从基线值，最好使用不同色图显示相对降低和相对增加面积的地区。</p>
<p>选择离散色板的规则类似于顺序色板，除了你想满足一个强调的颜色中点以及用不同起始颜色的两个相对微妙的变化。同样重要的是，起始值的亮度和饱和度是相同的。</p>
<p>同样重要的是要强调，应该避免使用红色和绿色，因为大量的潜在观众将无法分辨它们。</p>
<p>你不应该感到惊讶的是，Color Brewer颜色字典里拥有一套精心挑选的离散颜色映射:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sns.palplot(sns.color_palette(&quot;BrBG&quot;, 7))</span><br><span class="line">sns.palplot(sns.color_palette(&quot;RdBu_r&quot;, 7))</span><br></pre></td></tr></table></figure>
<p><img src="https://pic3.zhimg.com/80/v2-82c566f9a56048e6938994f4a4bf8701_hd.jpg" alt="img"></p>
<p><img src="https://pic2.zhimg.com/80/v2-53b695758fee38c08e5b1708f3ee0afa_hd.jpg" alt="img"></p>
<p>另一个在matplotlib中建立的明智的选择是coolwarm面板。请注意，这个颜色映射在中间值和极端之间并没有太大的对比。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.palplot(sns.color_palette(&quot;coolwarm&quot;, 7))</span><br></pre></td></tr></table></figure>
<p><img src="https://pic2.zhimg.com/80/v2-7910df5f0403079b5a2f4c3bd1472640_hd.jpg" alt="img"></p>
<p>用diverging_palette()使用定制离散色板</p>
<p>你也可以使用海运功能diverging_palette()为离散的数据创建一个定制的颜色映射。（当然也有一个类似配套的互动工具：choose_diverging_palette()）。该函数使用husl颜色系统的离散色板。你需随意传递两种颜色，并设定明度和饱和度的端点。函数将使用husl的端点值及由此产生的中间值进行均衡。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sns.palplot(sns.diverging_palette(220, 20, n=7))</span><br><span class="line">sns.palplot(sns.diverging_palette(145, 280, s=85, l=25, n=7))</span><br></pre></td></tr></table></figure>
<p><img src="https://pic4.zhimg.com/80/v2-5c105fb1180c8ea2de008284f5946833_hd.jpg" alt="img"></p>
<p><img src="https://pic3.zhimg.com/80/v2-986c5b789c5d47aef369a811f4878678_hd.jpg" alt="img"></p>
<p>sep参数控制面板中间区域的两个渐变的宽度。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.palplot(sns.diverging_palette(10, 220, sep=80, n=7))</span><br></pre></td></tr></table></figure>
<p><img src="https://pic4.zhimg.com/80/v2-752f50c1b496ea09cfa146150a5fe65c_hd.jpg" alt="img"></p>
<p>也可以用中间的色调来选择调色，而不是用亮度</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.palplot(sns.diverging_palette(255, 133, l=60, n=7, center=&quot;dark&quot;))</span><br></pre></td></tr></table></figure>
<p><img src="https://pic4.zhimg.com/80/v2-4ae67f94a2ecbc090a991769ba81e43c_hd.jpg" alt="img"></p>
<p>用set_palette()更改色变的默认值</p>
<p>color_palette() 函数有一个名为set_palette()的配套。它们之间的关系类似于在美学教程中涉及的aesthetics tutorial. set_palette()。set_palette()接受与color_palette()相同的参数，但是它会更改默认的matplotlib参数，以便成为所有的调色板配置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def sinplot(flip=1):</span><br><span class="line">    x = np.linspace(0, 14, 100)</span><br><span class="line">    for i in range(1, 7):</span><br><span class="line">        plt.plot(x, np.sin(x + i * .5) * (7 - i) * flip)</span><br><span class="line">sns.set_palette(&quot;husl&quot;)</span><br><span class="line">sinplot()</span><br></pre></td></tr></table></figure>
<p><img src="https://pic2.zhimg.com/80/v2-03706b0555fe936436722318fd52f79c_hd.jpg" alt="img"></p>
<p>color_palette()函数也可以在一个with块中使用，以达到临时更改调色板的目的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">with sns.color_palette(&quot;PuBuGn_d&quot;):</span><br><span class="line">    sinplot()</span><br></pre></td></tr></table></figure>
<p><img src="https://pic3.zhimg.com/80/v2-a66aeecfd2939bf38b9794e10520d618_hd.jpg" alt="img"></p>
<p>简单常用色彩总结：</p>
<ul>
<li>分类：hls husl Paired Set1~Set3（色调不同）</li>
<li>连续：Blues[蓝s，颜色+s] BuGn[蓝绿] cubehelix（同色系渐变）</li>
<li>离散：BrBG[棕绿] RdBu[红蓝] coolwarm[冷暖]（双色对称）</li>
</ul>
<h2 id="本章后记"><a href="#本章后记" class="headerlink" title="本章后记"></a>本章后记</h2><p>这章内容确认让对色彩与不同数据形式的图像之间的关系有了新的认识，恐怕色让图形好看和更有格调仅仅只是初级阶段。然而文中涉及了大量的色彩专用的名词和理论，只能不求甚解的翻出来强行理解了，谬误在所难免，欢迎各位大神指正，万分感谢！</p>
<h2 id="第三章-分布数据集的可视化"><a href="#第三章-分布数据集的可视化" class="headerlink" title="第三章 分布数据集的可视化"></a>第三章 分布数据集的可视化</h2><p>在处理一组数据时，通常首先要做的是了解变量是如何分布的。这一章将简要介绍seborn中用于检查单变量和双变量分布的一些工具。你可能还想看看分类变量的章节，来看看函数的例子，这些函数让我们很容易比较变量的分布。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">%matplotlib inline</span><br><span class="line">import numpy as np</span><br><span class="line">import pandas as pd</span><br><span class="line">from scipy import stats, integrate</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line"></span><br><span class="line">import seaborn as sns</span><br><span class="line">sns.set(color_codes=True)</span><br><span class="line"></span><br><span class="line">np.random.seed(sum(map(ord, &quot;distributions&quot;)))</span><br></pre></td></tr></table></figure>
<h2 id="单变量分布"><a href="#单变量分布" class="headerlink" title="单变量分布"></a>单变量分布</h2><p>最方便的方式是快速查看单变量分布无疑是使用distplot()函数。默认情况下，这将绘制一个直方图，并拟合出核密度估计(KDE)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = np.random.normal(size=100)</span><br><span class="line">sns.distplot(x);</span><br></pre></td></tr></table></figure>
<p><img src="https://pic2.zhimg.com/80/v2-4c9f4c989b6281f1d1b9306a920e0602_hd.jpg" alt="img"></p>
<h2 id="直方图"><a href="#直方图" class="headerlink" title="直方图"></a>直方图</h2><p>直方图应当是非常熟悉的函数了，在matplotlib中就存在hist函数。直方图通过在数据的范围内切成数据片段，然后绘制每个数据片段中的观察次数，来表示整体数据的分布。</p>
<p>为了说明这一点，我们删除密度曲线并添加了地毯图，每个观察点绘制一个小的垂直刻度。您可以使用rugplot()函数来制作地毯图，但它也可以在distplot()中使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.distplot(x, kde=False, rug=True);</span><br></pre></td></tr></table></figure>
<p><img src="https://pic2.zhimg.com/80/v2-4eb0c4fdf780a89712e1ea2bc98473ca_hd.jpg" alt="img"></p>
<p>绘制直方图时，主要的选择是使用切分数据片段的数量或在何位置切分数据片段。 distplot()使用一个简单的规则来很好地猜测并给予默认的切分数量，但尝试更多或更少的数据片段可能会显示出数据中的其他特征：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.distplot(x, bins=20, kde=False, rug=True);</span><br></pre></td></tr></table></figure>
<p><img src="https://pic3.zhimg.com/80/v2-b50ed85f634b9fd49b7934b606e75c7b_hd.jpg" alt="img"></p>
<h2 id="核密度估计-KDE-Kernel-density-estimaton"><a href="#核密度估计-KDE-Kernel-density-estimaton" class="headerlink" title="核密度估计(KDE) Kernel density estimaton"></a>核密度估计(KDE) Kernel density estimaton</h2><p>或许你对核密度估计可能不像直方图那么熟悉，但它是绘制分布形状的有力工具。如同直方图一样，KDE图会对一个轴上的另一轴的高度的观测密度进行描述：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.distplot(x, hist=False, rug=True);</span><br></pre></td></tr></table></figure>
<p><img src="https://pic3.zhimg.com/80/v2-f61940455efe60159870ca345a334c97_hd.jpg" alt="img"></p>
<p>绘制KDE比绘制直方图更有计算性。所发生的是，每一个观察都被一个以这个值为中心的正态（ 高斯）曲线所取代。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">x = np.random.normal(0, 1, size=30)</span><br><span class="line">bandwidth = 1.06 * x.std() * x.size ** (-1 / 5.)</span><br><span class="line">support = np.linspace(-4, 4, 200)</span><br><span class="line"></span><br><span class="line">kernels = []</span><br><span class="line">for x_i in x:</span><br><span class="line"></span><br><span class="line">    kernel = stats.norm(x_i, bandwidth).pdf(support)</span><br><span class="line">    kernels.append(kernel)</span><br><span class="line">    plt.plot(support, kernel, color=&quot;r&quot;)</span><br><span class="line"></span><br><span class="line">sns.rugplot(x, color=&quot;.2&quot;, linewidth=3);</span><br></pre></td></tr></table></figure>
<p><img src="https://pic3.zhimg.com/80/v2-95ccd4431c8d8ff0a9272eba9c539d73_hd.jpg" alt="img"></p>
<p>接下来，这些曲线可以用来计算支持网格中每个点的密度值。得到的曲线再用归一化使得它下面的面积等于1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">density = np.sum(kernels, axis=0)</span><br><span class="line">density /= integrate.trapz(density, support)</span><br><span class="line">plt.plot(support, density);</span><br></pre></td></tr></table></figure>
<p><img src="https://pic3.zhimg.com/80/v2-80815da5ac27e9014310e3764262d883_hd.jpg" alt="img"></p>
<p>我们可以看到，如果我们在seaborn中使用kdeplot()函数，我们得到相同的曲线。 这个函数由distplot()使用，但是当您只想要密度估计时，它提供了一个更直接的界面，更容易访问其他选项：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.kdeplot(x, shade=True);</span><br></pre></td></tr></table></figure>
<p><img src="https://pic1.zhimg.com/80/v2-b724e02aebc60307cd03eb62b9d78da5_hd.jpg" alt="img"></p>
<p>KDE的带宽bandwidth（bw）参数控制估计对数据的拟合程度，与直方图中的bin(数据切分数量参数)大小非常相似。 它对应于我们上面绘制的内核的宽度。 默认中会尝试使用通用引用规则猜测一个适合的值，但尝试更大或更小的值可能会有所帮助：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sns.kdeplot(x)</span><br><span class="line">sns.kdeplot(x, bw=.2, label=&quot;bw: 0.2&quot;)</span><br><span class="line">sns.kdeplot(x, bw=2, label=&quot;bw: 2&quot;)</span><br><span class="line">plt.legend();</span><br></pre></td></tr></table></figure>
<p><img src="https://pic1.zhimg.com/80/v2-c2476971d0f6b4b41c225826479401b3_hd.jpg" alt="img"></p>
<p>如上所述，高斯KDE过程的性质意味着估计延续了数据集中最大和最小的值。 可以通过cut参数来控制绘制曲线的极值值的距离; 然而，这只影响曲线的绘制方式，而不是曲线如何拟合：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sns.kdeplot(x, shade=True, cut=0)</span><br><span class="line">sns.rugplot(x);</span><br></pre></td></tr></table></figure>
<p><img src="https://pic1.zhimg.com/80/v2-25d44e68e4f633fd4d8839f1aad6a706_hd.jpg" alt="img"></p>
<h2 id="拟合参数分布"><a href="#拟合参数分布" class="headerlink" title="拟合参数分布"></a>拟合参数分布</h2><p>还可以使用distplot()将参数分布拟合到数据集，并可视化地评估其与观察数据的对应关系：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = np.random.gamma(6, size=200)</span><br><span class="line">sns.distplot(x, kde=False, fit=stats.gamma);</span><br></pre></td></tr></table></figure>
<p><img src="https://pic3.zhimg.com/80/v2-45d1af1920f35dcbe81c390f5b0819cd_hd.jpg" alt="img"></p>
<h2 id="绘制双变量分布"><a href="#绘制双变量分布" class="headerlink" title="绘制双变量分布"></a>绘制双变量分布</h2><p>在绘制两个变量的双变量分布也是有用的。在seaborn中这样做的最简单的方法就是在jointplot()函数中创建一个多面板数字，显示两个变量之间的双变量（或联合）关系以及每个变量的单变量（或边际）分布和轴。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mean, cov = [0, 1], [(1, .5), (.5, 1)]</span><br><span class="line">data = np.random.multivariate_normal(mean, cov, 200)</span><br><span class="line">df = pd.DataFrame(data, columns=[&quot;x&quot;, &quot;y&quot;])</span><br></pre></td></tr></table></figure>
<p><img src="https://pic3.zhimg.com/80/v2-03567ded62f761c697aaa298b2fad954_hd.jpg" alt="img"></p>
<h2 id="散点图"><a href="#散点图" class="headerlink" title="散点图"></a>散点图</h2><p>双变量分布的最熟悉的可视化方式无疑是散点图，其中每个观察结果以x和y值表示。这是两个方面的地毯图。可以使用matplotlib中的plt.scatter函数绘制散点图，它也是jointplot()函数显示的默认方式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.jointplot(x=&quot;x&quot;, y=&quot;y&quot;, data=df);</span><br></pre></td></tr></table></figure>
<h2 id="HexBin图"><a href="#HexBin图" class="headerlink" title="HexBin图"></a>HexBin图</h2><p>直方图的双变量类似物被称为“hexbin”图，因为它显示了落在六边形仓内的观测数。该图适用于较大的数据集。通过matplotlib plt.hexbin函数和jointplot()中的样式可以实现。 它最好使用白色背景：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x, y = np.random.multivariate_normal(mean, cov, 1000).T</span><br><span class="line">with sns.axes_style(&quot;white&quot;):</span><br><span class="line">    sns.jointplot(x=x, y=y, kind=&quot;hex&quot;, color=&quot;k&quot;);</span><br></pre></td></tr></table></figure>
<p><img src="https://pic3.zhimg.com/80/v2-233cd7204e9bd51371dacaa573d35e94_hd.jpg" alt="img"></p>
<h2 id="核密度估计"><a href="#核密度估计" class="headerlink" title="核密度估计"></a>核密度估计</h2><p>使用上述内核密度估计程序可视化双变量分布也是可行的。在seaborn中，这种图用等高线图显示，可以在jointplot()中作为样式传入参数使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.jointplot(x=&quot;x&quot;, y=&quot;y&quot;, data=df, kind=&quot;kde&quot;);</span><br></pre></td></tr></table></figure>
<p><img src="https://pic2.zhimg.com/80/v2-1e36212ecf46cdf74b9d6850f3620f15_hd.jpg" alt="img"></p>
<p>还可以使用kdeplot()函数绘制二维核密度图。这样可以将这种绘图绘制到一个特定的（可能已经存在的）matplotlib轴上，而jointplot()函数只能管理自己：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">f, ax = plt.subplots(figsize=(6, 6))</span><br><span class="line">sns.kdeplot(df.x, df.y, ax=ax)</span><br><span class="line">sns.rugplot(df.x, color=&quot;g&quot;, ax=ax)</span><br><span class="line">sns.rugplot(df.y, vertical=True, ax=ax);</span><br></pre></td></tr></table></figure>
<p><img src="https://pic4.zhimg.com/80/v2-ee67bc11795b85749a60376158a93ce7_hd.jpg" alt="img"></p>
<p>如果是希望更连续地显示双变量密度，您可以简单地增加n_levels参数增加轮廓级数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f, ax = plt.subplots(figsize=(6, 6))</span><br><span class="line">cmap = sns.cubehelix_palette(as_cmap=True, dark=0, light=1, reverse=True)</span><br><span class="line">sns.kdeplot(df.x, df.y, cmap=cmap, n_levels=60, shade=True);</span><br></pre></td></tr></table></figure>
<p><img src="https://pic2.zhimg.com/80/v2-c0f2742a4086afc0ca7723b6d6d69ecc_hd.jpg" alt="img"></p>
<p>jointplot()函数使用JointGrid来管理。为了获得更多的灵活性，您可能需要直接使用JointGrid绘制图形。jointplot()在绘制后返回JointGrid对象，您可以使用它来添加更多图层或调整可视化的其他方面：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">g = sns.jointplot(x=&quot;x&quot;, y=&quot;y&quot;, data=df, kind=&quot;kde&quot;, color=&quot;m&quot;)</span><br><span class="line">g.plot_joint(plt.scatter, c=&quot;w&quot;, s=30, linewidth=1, marker=&quot;+&quot;)</span><br><span class="line">g.ax_joint.collections[0].set_alpha(0)</span><br><span class="line">g.set_axis_labels(&quot;$X$&quot;, &quot;$Y$&quot;);</span><br></pre></td></tr></table></figure>
<p><img src="https://pic2.zhimg.com/80/v2-6475a5dfb714783fd8eaafba94e300cd_hd.jpg" alt="img"></p>
<h2 id="呈现数据集中成对的关系"><a href="#呈现数据集中成对的关系" class="headerlink" title="呈现数据集中成对的关系"></a>呈现数据集中成对的关系</h2><p>要在数据集中绘制多个成对双变量分布，可以使用pairplot()函数。这将创建一个轴的矩阵，并显示DataFrame中每对列的关系。默认情况下，它也绘制每个变量在对角轴上的单变量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">iris = sns.load_dataset(&quot;iris&quot;)</span><br><span class="line">sns.pairplot(iris);</span><br></pre></td></tr></table></figure>
<p><img src="https://pic2.zhimg.com/80/v2-570bac7c3154aa1dd684da7790f3d432_hd.jpg" alt="img"></p>
<p>对于jointplot()和JointGrid之间的关系，pairplot()函数是建立在一个PairGrid对象上的，可以直接使用它来获得更大的灵活性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">g = sns.PairGrid(iris)</span><br><span class="line">g.map_diag(sns.kdeplot)</span><br><span class="line">g.map_offdiag(sns.kdeplot, cmap=&quot;Blues_d&quot;, n_levels=6);</span><br></pre></td></tr></table></figure>
<p><img src="https://pic3.zhimg.com/80/v2-2754ddfe86d6d99b205a5327d67a32d5_hd.jpg" alt="img"></p>
<p>这章介绍的针对回归类型的散点数据的可视化可能是未来机器学习最直接的助理，这章给我的感悟很多。</p>
<p>许多数据集包含多个定量变量，分析的目的通常是将这些变量相互关联起来。 我们以前讨论过可以通过显示两个变量的联合分布来实现的功能。 然而，使用统计模型来估计两个噪声观测组之间的简单关系可能是非常有帮助的。 本章讨论的功能将通过线性回归的通用框架进行。</p>
<p>在Tukey的精神中，Seaborn的回归图主要是为了添加一个视觉指南，有助于在探索性数据分析期间强调数据集中的模式。 也就是说，Seaborn本身并不是统计分析的一揽子计划。 要获得与回归模型拟合相关的量化措施，您应该使用<a href="http://link.zhihu.com/?target=http%3A//www.statsmodels.org/stable/index.html" target="_blank" rel="noopener">statsmodels</a>。 然而，Seaborn的目标是通过可视化快速，轻松地探索数据集，使之变得与通过统计表格来探索数据集一样重要（如果不是更重要的话）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">%matplotlib inline</span><br><span class="line">import numpy as np</span><br><span class="line">import pandas as pd</span><br><span class="line">import matplotlib as mpl</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line"></span><br><span class="line">import seaborn as sns</span><br><span class="line">sns.set(color_codes=True)</span><br><span class="line"></span><br><span class="line">np.random.seed(sum(map(ord, &quot;regression&quot;)))</span><br><span class="line"></span><br><span class="line">tips = sns.load_dataset(&quot;tips&quot;)</span><br></pre></td></tr></table></figure>
<h2 id="绘制线性回归模型的函数"><a href="#绘制线性回归模型的函数" class="headerlink" title="绘制线性回归模型的函数"></a>绘制线性回归模型的函数</h2><p>使用Seaborn中的两个主要功能可视化通过回归确定的线性关系。这些函数regplot()和lmplot()是密切相关的，并且共享了大部分的核心功能。然而，了解他们不同的方式很重要，以便您可以快速为特定工作选择正确的工具。</p>
<p>在最简单的调用中，两个函数绘制了两个变量x和y的散点图，然后拟合回归模型y〜x并绘制了该回归线的结果回归线和95％置信区间：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.regplot(x=&quot;total_bill&quot;, y=&quot;tip&quot;, data=tips);</span><br></pre></td></tr></table></figure>
<p><img src="https://pic2.zhimg.com/80/v2-d11475667844660f0c436f3b0bccdad4_hd.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.lmplot(x=&quot;total_bill&quot;, y=&quot;tip&quot;, data=tips);</span><br></pre></td></tr></table></figure>
<p><img src="https://pic3.zhimg.com/80/v2-23f70dd3ea13ab7f324d276cc2008d95_hd.jpg" alt="img"></p>
<p>很显然，所得到的的图的结果是相同的，除了图形形状略有些不同，这里会简短的解释。</p>
<p>目前，要知道的另一个主要区别是regplot()以各种格式接受x和y变量，包括numpy数组、Pandas的Series列或DataFrame对象的变量引用；不一样的是，lmplot()将数据集作为一个必需的参数，而x和y变量必须指定为字符串。这种数据格式称为“长格式”或“整洁”数据。除了这种输入灵活性，regplot()可以看做是拥有lmplot()特征的子集，所以后面将使用后者进行演示。</p>
<p>备注：</p>
<blockquote>
<p>这里官方的例子实际上并不好，比较容易的理解方式是：上面的结果可以在regplot()函数中通过只传入x和y绘出：sns.regplot(x=tips[“total_bill”], y=tips[“tip”])；而相应的sns.lmplot(x=tips[“total_bill”], y=tips[“tip”])这种写法就会报错，因为数据集data是lmplot()的必传参数。</p>
</blockquote>
<p>当其中一个变量取值为离散型的时候，可以拟合一个线性回归。然而，这种数据集生成的简单散点图通常不是最优的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">tips.head()</span><br><span class="line"></span><br><span class="line">	total_bill 	tip 	sex 	smoker 	day 	time 	size 	big_tip</span><br><span class="line">0 	16.99 	1.01 	Female 	No 	Sun 	Dinner 	2 	False</span><br><span class="line">1 	10.34 	1.66 	Male 	No 	Sun 	Dinner 	3 	True</span><br><span class="line">2 	21.01 	3.50 	Male 	No 	Sun 	Dinner 	3 	True</span><br><span class="line">3 	23.68 	3.31 	Male 	No 	Sun 	Dinner 	2 	False</span><br><span class="line">4 	24.59 	3.61 	Female 	No 	Sun 	Dinner 	4 	False</span><br><span class="line">sns.lmplot(data=tips,x=&quot;size&quot;,y=&quot;tip&quot;)</span><br></pre></td></tr></table></figure>
<p><img src="https://pic3.zhimg.com/80/v2-0dc26291b5ab53e04aa263644fb25de4_hd.jpg" alt="img"></p>
<p>一个常用的方法是为离散值添加一些随机噪声的“抖动”(jitter)，使得这些值的分布更加明晰。</p>
<p>值得注意的是，抖动仅适用于散点图数据，且不会影响拟合的回归线本身</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.lmplot(x=&quot;size&quot;, y=&quot;tip&quot;, data=tips, x_jitter=.05);</span><br></pre></td></tr></table></figure>
<p><img src="https://pic4.zhimg.com/80/v2-200767ca2c93d8dd165cd130be128aba_hd.jpg" alt="img"></p>
<p>另一种选择是在每个独立的数据分组中对观察结果进行折叠，以绘制中心趋势的估计以及置信区间：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.lmplot(x=&quot;size&quot;, y=&quot;tip&quot;, data=tips, x_estimator=np.mean);</span><br></pre></td></tr></table></figure>
<p><img src="https://pic4.zhimg.com/80/v2-915b1d306d288386640f61e8d75c2b5e_hd.jpg" alt="img"></p>
<h2 id="不同类型的模型拟合"><a href="#不同类型的模型拟合" class="headerlink" title="不同类型的模型拟合"></a>不同类型的模型拟合</h2><p>上面使用的简单线性回归模型非常简单，但是，它不适用于某些种类的数据集。 <a href="http://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Anscombe%2527s_quartet" target="_blank" rel="noopener">Anscombe’s quartet</a>数据集显示了一些简单线性回归提供了简单目视检查清楚显示差异的关系估计的例子。 例如，在第一种情况下，线性回归是一个很好的模型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">anscombe = sns.load_dataset(&quot;anscombe&quot;)</span><br><span class="line">sns.lmplot(x=&quot;x&quot;, y=&quot;y&quot;, data=anscombe.query(&quot;dataset == &apos;I&apos;&quot;),</span><br><span class="line">           ci=None, scatter_kws=&#123;&quot;s&quot;: 80&#125;);</span><br></pre></td></tr></table></figure>
<p><img src="https://pic1.zhimg.com/80/v2-11fb168d4145caa9ba18cfb33fab665e_hd.jpg" alt="img"></p>
<p>第二个数据集中的线性关系是一样的，但是基本清楚地表明这不是一个好的模型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sns.lmplot(x=&quot;x&quot;, y=&quot;y&quot;, data=anscombe.query(&quot;dataset == &apos;II&apos;&quot;),</span><br><span class="line">           ci=None, scatter_kws=&#123;&quot;s&quot;: 80&#125;);</span><br></pre></td></tr></table></figure>
<p><img src="https://pic4.zhimg.com/80/v2-1022e90e7c26a3f650d2a77b5f35ca8e_hd.jpg" alt="img"></p>
<p>在存在这些高阶关系的情况下，lmplot()和regplot()可以拟合多项式回归模型来拟合数据集中的简单类型的非线性趋势：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sns.lmplot(x=&quot;x&quot;, y=&quot;y&quot;, data=anscombe.query(&quot;dataset == &apos;II&apos;&quot;),</span><br><span class="line">           order=2, ci=None, scatter_kws=&#123;&quot;s&quot;: 80&#125;);</span><br></pre></td></tr></table></figure>
<p><img src="https://pic3.zhimg.com/80/v2-ade063eecbe8de6613831dc554f7bfcf_hd.jpg" alt="img"></p>
<p>除了正在研究的主要关系之外，“异常值”观察还有一个不同的问题，它们由于某种原因而偏离了主要关系：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sns.lmplot(x=&quot;x&quot;, y=&quot;y&quot;, data=anscombe.query(&quot;dataset == &apos;III&apos;&quot;),</span><br><span class="line">           ci=None, scatter_kws=&#123;&quot;s&quot;: 80&#125;);</span><br></pre></td></tr></table></figure>
<p><img src="https://pic2.zhimg.com/80/v2-6924a185e029a7958e7c9beb57c615fa_hd.jpg" alt="img"></p>
<p>在有异常值的情况下，它可以使用不同的损失函数来减小相对较大的残差，拟合一个健壮的回归模型，传入robust=True：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sns.lmplot(x=&quot;x&quot;, y=&quot;y&quot;, data=anscombe.query(&quot;dataset == &apos;III&apos;&quot;),</span><br><span class="line">           robust=True, ci=None, scatter_kws=&#123;&quot;s&quot;: 80&#125;);</span><br></pre></td></tr></table></figure>
<p><img src="https://pic1.zhimg.com/80/v2-a4fb4681f702314315e6351822710860_hd.jpg" alt="img"></p>
<p>当y变量是二进制时，简单的线性回归也“工作”了，但提供了不可信的预测结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tips[&quot;big_tip&quot;] = (tips.tip / tips.total_bill) &gt; .15</span><br><span class="line">sns.lmplot(x=&quot;total_bill&quot;, y=&quot;big_tip&quot;, data=tips,</span><br><span class="line">           y_jitter=.03);</span><br></pre></td></tr></table></figure>
<p><img src="https://pic4.zhimg.com/80/v2-28961ac44138618edffeef42b40d65e8_hd.jpg" alt="img"></p>
<p>在这种情况下，解决方案是拟合逻辑(Logistic)回归，使得回归线显示给定值x的y=1的估计概率：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sns.lmplot(x=&quot;total_bill&quot;, y=&quot;big_tip&quot;, data=tips,</span><br><span class="line">           logistic=True, y_jitter=.03);</span><br></pre></td></tr></table></figure>
<p><img src="https://pic4.zhimg.com/80/v2-f5c4894edba577d09861e1421df61854_hd.jpg" alt="img"></p>
<p>请注意，逻辑回归估计比简单回归计算密集程度（Robust回归也是如此），并且由于使用引导程序计算回归线周围的置信区间，您可能希望将其关闭获得更快的迭代速度（使用参数ci=None）。</p>
<p>一个完全不同的方法是使用一个<a href="http://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Local_regression" target="_blank" rel="noopener">lowess smoother</a>拟合非参数回归。 这种方法具有最少的假设，尽管它是计算密集型的，因此目前根本不计算置信区间：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sns.lmplot(x=&quot;total_bill&quot;, y=&quot;tip&quot;, data=tips,</span><br><span class="line">           lowess=True);</span><br></pre></td></tr></table></figure>
<p><img src="https://pic3.zhimg.com/80/v2-fa45001aca25e829494abc9a3c63ee20_hd.jpg" alt="img"></p>
<p>residplot()是一个有用的工具，用于检查简单的回归模型是否拟合数据集。它拟合并移除一个简单的线性回归，然后绘制每个观察值的残差值。 理想情况下，这些值应随机散布在y = 0附近：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sns.residplot(x=&quot;x&quot;, y=&quot;y&quot;, data=anscombe.query(&quot;dataset == &apos;I&apos;&quot;),</span><br><span class="line">              scatter_kws=&#123;&quot;s&quot;: 80&#125;);</span><br></pre></td></tr></table></figure>
<p><img src="https://pic2.zhimg.com/80/v2-da316f22c219b098c7a02db9a0996c48_hd.jpg" alt="img"></p>
<p>如果残差中有结构，则表明简单的线性回归是不合适的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sns.residplot(x=&quot;x&quot;, y=&quot;y&quot;, data=anscombe.query(&quot;dataset == &apos;II&apos;&quot;),</span><br><span class="line">              scatter_kws=&#123;&quot;s&quot;: 80&#125;);</span><br></pre></td></tr></table></figure>
<p><img src="https://pic2.zhimg.com/80/v2-bfa3f4084aaa8888b70ae957d2e6a2d1_hd.jpg" alt="img"></p>
<h2 id="调节其他变量"><a href="#调节其他变量" class="headerlink" title="调节其他变量"></a>调节其他变量</h2><p>上面的图表显示了许多方法来探索一对变量之间的关系。然而，通常，一个更有趣的问题是“这两个变量之间的关系如何作为第三个变量的函数而变化？”这是regplot()和lmplot()之间的区别。 虽然regplot()总是显示单个关系，lmplot()将regplot()与FacetGrid结合在一起，提供了一个简单的界面，可以在“faceted”图上显示线性回归，从而允许您探索与多达三个其他类别变量的交互。</p>
<p>分类关系的最佳方式是绘制相同轴上的两个级别，并使用颜色来区分它们：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.lmplot(x=&quot;total_bill&quot;, y=&quot;tip&quot;, hue=&quot;smoker&quot;, data=tips);</span><br></pre></td></tr></table></figure>
<p><img src="https://pic1.zhimg.com/80/v2-284fd1744f3fc70dd08de901fda97b13_hd.jpg" alt="img"></p>
<p>除了颜色之外，还可以使用不同的散点图标记来使黑色和白色的图像更好地绘制。 您还可以完全控制所用的颜色：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sns.lmplot(x=&quot;total_bill&quot;, y=&quot;tip&quot;, hue=&quot;smoker&quot;, data=tips,</span><br><span class="line">           markers=[&quot;o&quot;, &quot;x&quot;], palette=&quot;Set1&quot;);</span><br></pre></td></tr></table></figure>
<p><img src="https://pic1.zhimg.com/80/v2-ff5b754c8df7a23667b65e5b71918843_hd.jpg" alt="img"></p>
<p>要添加另一个变量，您可以绘制多个“facet”，每个级别的变量出现在网格的行或列中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.lmplot(x=&quot;total_bill&quot;, y=&quot;tip&quot;, hue=&quot;smoker&quot;, col=&quot;time&quot;, data=tips);</span><br></pre></td></tr></table></figure>
<p><img src="https://pic3.zhimg.com/80/v2-23ef0b29a7914c1da12851941be5245f_hd.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sns.lmplot(x=&quot;total_bill&quot;, y=&quot;tip&quot;, hue=&quot;smoker&quot;,</span><br><span class="line">           col=&quot;time&quot;, row=&quot;sex&quot;, data=tips);</span><br></pre></td></tr></table></figure>
<p><img src="https://pic1.zhimg.com/80/v2-c49c23d2b605cadcc894e4c82a6203df_hd.jpg" alt="img"></p>
<h2 id="控制绘制的大小和形状"><a href="#控制绘制的大小和形状" class="headerlink" title="控制绘制的大小和形状"></a>控制绘制的大小和形状</h2><p>在我们注意到由regplot()和lmplot()创建的默认绘图看起来是一样的，但在轴上却具有不同大小和形状。 这是因为func：regplot是一个“轴级”功能绘制到特定的轴上。 这意味着您可以自己制作多面板图形，并精确控制回归图的位置。 如果没有提供轴，它只需使用“当前活动的”轴，这就是为什么默认绘图与大多数其他matplotlib函数具有相同的大小和形状的原因。要控制大小，您需要自己创建一个图形对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f, ax = plt.subplots(figsize=(5, 6))</span><br><span class="line">sns.regplot(x=&quot;total_bill&quot;, y=&quot;tip&quot;, data=tips, ax=ax);</span><br></pre></td></tr></table></figure>
<p><img src="https://pic2.zhimg.com/80/v2-d230b8523f6db3b4131b7d27bd59db97_hd.jpg" alt="img"></p>
<p>相反，lmplot()图的大小和形状通过FacetGrid界面使用size和aspect参数进行控制，这些参数适用于每个图中的设置，而不是整体图形：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sns.lmplot(x=&quot;total_bill&quot;, y=&quot;tip&quot;, col=&quot;day&quot;, data=tips,</span><br><span class="line">           col_wrap=2, size=3);</span><br></pre></td></tr></table></figure>
<p><img src="https://pic3.zhimg.com/80/v2-a42a7a8428bdea6196f4d1f2e5fa4fd5_hd.jpg" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sns.lmplot(x=&quot;total_bill&quot;, y=&quot;tip&quot;, col=&quot;day&quot;, data=tips,</span><br><span class="line">           aspect=.5);</span><br></pre></td></tr></table></figure>
<p><img src="https://pic2.zhimg.com/80/v2-a1989baab51ac7fceb836838e93f6c50_hd.jpg" alt="img"></p>
<h2 id="在其他背景下绘制回归"><a href="#在其他背景下绘制回归" class="headerlink" title="在其他背景下绘制回归"></a>在其他背景下绘制回归</h2><p>另外一些Seaborn函数在更大，更复杂的绘制中使用regplot()。 第一个是在上一章分布介绍的jointplot()函数。 除了前面讨论的绘图样式之外，jointplot()可以使用regplot()通过传递kind =”reg”来显示关节轴上的线性回归拟合：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.jointplot(x=&quot;total_bill&quot;, y=&quot;tip&quot;, data=tips, kind=&quot;reg&quot;);</span><br></pre></td></tr></table></figure>
<p><img src="https://pic2.zhimg.com/80/v2-f9fddfabd62ba91a9836b5d5c82e7b77_hd.jpg" alt="img"></p>
<p>使用kind=”reg”的pairplot()函数结合了regplot()和PairGrid来显示数据集中变量之间的线性关系。 注意这是不同于lmplot()的。 在下图中，两轴在第三个变量的两个级别上不显示相同的关系; 相反，PairGrid()用于显示数据集中变量的不同配对之间的多个关系：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sns.pairplot(tips, x_vars=[&quot;total_bill&quot;, &quot;size&quot;], y_vars=[&quot;tip&quot;],</span><br><span class="line">             size=5, aspect=.8, kind=&quot;reg&quot;);</span><br></pre></td></tr></table></figure>
<p><img src="https://pic3.zhimg.com/80/v2-7d0d715fb0ce8d1be8ea04ec4eb12e2e_hd.jpg" alt="img"></p>
<p>类似lmplot()，但不同于jointplot()，使用hue参数在pairplot()中内置了一个附加分类变量的条件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sns.pairplot(tips, x_vars=[&quot;total_bill&quot;, &quot;size&quot;], y_vars=[&quot;tip&quot;],</span><br><span class="line">             hue=&quot;smoker&quot;, size=5, aspect=.8, kind=&quot;reg&quot;);</span><br></pre></td></tr></table></figure>
<p><img src="https://pic3.zhimg.com/80/v2-b3676d0e26bb8f06ba6aafb3d713c182_hd.jpg" alt="img"></p>
<h2 id="第五章-分类数据的绘制"><a href="#第五章-分类数据的绘制" class="headerlink" title="第五章 分类数据的绘制"></a>第五章 分类数据的绘制</h2><p>我们之前探讨了如何使用散点图和回归模型拟合来可视化两个变量之间的关系，以及如何在其他分类变量的层次之间进行展示。 当然，还有一大类问题就是分类数据的问题了？ 在这种情况下，散点图和回归模型方法将不起作用。当然，有几个观察可视化这种关系的选择，我们将在本章中讨论。</p>
<p>非常实用的方法是将Seaborn的分类图分为三类，将分类变量每个级别的每个观察结果显示出来，显示每个观察分布的抽象表示，以及应用统计估计显示的权重趋势和置信区间：</p>
<ul>
<li>第一个包括函数swarmplot()和stripplot()</li>
<li>第二个包括函数boxplot()和violinplot()</li>
<li>第三个包括函数barplot()和pointplt()</li>
</ul>
<p>在了解他们如何接受数据传入方面，尽管每个参数都聚有控制应用于该数据可视化细节的特定参数，但这些功能都共享一个基本的API。</p>
<p>这与之前的regplot()和lmplot()的关系非常相似（未禾备注：在seaborn的构架中很容易分成这样两类用途相似，使用有所差异的替代方案函数）。在Seaborn中，相对低级别和相对高级别的方法用于定制分类数据的绘制图，上面列出的函数都是低级别的，他们绘制在特定的matplotlib轴上。还有更高级别的factorplot()（未禾备注：这是一个非常简明的快速绘制函数，具体用法会在最后有详细介绍），它将这些功能与FacetGrid结合，以便在面板的网格中应用分类图像。</p>
<p>使用“整洁”格式的DataFrame调用这些函数是最简单和最好的，尽管较低级别的函数也接受宽形式的DataFrames或简单的观察向量。见下面的例子。</p>
<blockquote>
<p>未禾备注：你甚至可以理解为这一章都是在具体学习factorplot()函数，快速、直接、功能强大的绘图函数谁不爱？</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">%matplotlib inline</span><br><span class="line">import numpy as np</span><br><span class="line">import pandas as pd</span><br><span class="line">import matplotlib as mpl</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">import seaborn as sns</span><br><span class="line">sns.set(style=&quot;whitegrid&quot;, color_codes=True)</span><br><span class="line"></span><br><span class="line">np.random.seed(sum(map(ord, &quot;categorical&quot;)))</span><br><span class="line">titanic = sns.load_dataset(&quot;titanic&quot;)</span><br><span class="line">tips = sns.load_dataset(&quot;tips&quot;)</span><br><span class="line">iris = sns.load_dataset(&quot;iris&quot;)</span><br></pre></td></tr></table></figure>
<h2 id="分类散点图"><a href="#分类散点图" class="headerlink" title="分类散点图"></a>分类散点图</h2><p>显示分类变量级别中某些定量变量的值的一种简单方法使用stripplot()，它会将分散图概括为其中一个变量是分类的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.stripplot(x=&quot;day&quot;, y=&quot;total_bill&quot;, data=tips);</span><br></pre></td></tr></table></figure>
<p><img src="https://pic1.zhimg.com/80/v2-eac310fc9db0ce1b8837481f32b345f0_hd.jpg" alt="img"></p>
<p>在条纹图中，散点图通常将重叠。这使得很难看到数据的完整分布。一个简单的解决方案是使用一些随机的“抖动”调整位置（仅沿着分类轴）</p>
<blockquote>
<p>未禾备注：抖动是平时可视化中的常用的观察“密度”的方法，除了使用参数抖动，特定的抖动需求也可以用numpy在数据上处理实现</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.stripplot(x=&quot;day&quot;, y=&quot;total_bill&quot;, data=tips, jitter=True);</span><br></pre></td></tr></table></figure>
<p><img src="https://pic2.zhimg.com/80/v2-c630edb2eed84ab81c55cbb7aea84149_hd.jpg" alt="img"></p>
<p>不同的方法是使用函数swarmplot()，它使用避免重叠点的算法将分类轴上的每个散点图点定位：</p>
<blockquote>
<p>未禾备注：道理上，即使抖动还是会有重叠的可能，所以这种方法可能更好</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.swarmplot(x=&quot;day&quot;, y=&quot;total_bill&quot;, data=tips);</span><br></pre></td></tr></table></figure>
<p><img src="https://pic4.zhimg.com/80/v2-b6a5c774a783e4a4352fd02f19fe9a8c_hd.jpg" alt="img"></p>
<p>当然也可以传入hue参数添加多个嵌套的分类变量。高于分类轴上的颜色和位置时冗余的，现在每个都提供有两个变量之一的信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.swarmplot(x=&quot;day&quot;, y=&quot;total_bill&quot;, hue=&quot;sex&quot;,data=tips);</span><br></pre></td></tr></table></figure>
<p><img src="https://pic3.zhimg.com/80/v2-fd71d973d0f4a8899368395c62293f08_hd.jpg" alt="img"></p>
<p>一般来说，Seaborn分类绘图功能试图从数据中推断类别的顺序。 如果您的数据有一个pandas分类数据类型，那么类别的默认顺序可以在那里设置。 对于其他数据类型，字符串类型的类别将按照它们在DataFrame中显示的顺序进行绘制，但是数组类别将被排序：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.swarmplot(x=&quot;size&quot;, y=&quot;total_bill&quot;, data=tips);</span><br></pre></td></tr></table></figure>
<p><img src="https://pic3.zhimg.com/80/v2-49256cda62e38f4033ff61dc6a5a9eb5_hd.jpg" alt="img"></p>
<p>使用这些图，将分类变量放在垂直轴上是非常有用的（当类别名称相对较长或有很多类别时，这一点特别有用）。 您可以使用orient关键字强制定向，但通常可以从传递给x和/或y的变量的数据类型推断绘图方向：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.swarmplot(x=&quot;total_bill&quot;, y=&quot;day&quot;, hue=&quot;time&quot;, data=tips);</span><br></pre></td></tr></table></figure>
<p><img src="https://pic2.zhimg.com/80/v2-f203413ad0071e91d54ba4baa662914e_hd.jpg" alt="img"></p>
<h2 id="分类内的观测分布"><a href="#分类内的观测分布" class="headerlink" title="分类内的观测分布"></a>分类内的观测分布</h2><p>分类散点图固然简单实用，但在某些特定的的情况下，他们可以提供的值的分布信息会变得及其有限（并不明晰）。 有几种方式可以方便的解决这个问题，在类别之间进行简单比较并汇总信息，我们快速讨论并比较一些适合这类数据观测的函数。</p>
<h2 id="箱线图"><a href="#箱线图" class="headerlink" title="箱线图"></a>箱线图</h2><p>第一个是熟悉的boxplot()。这种图形显示了分布的三个四分位值与极值。“晶须”延伸到低于和低四分位数的1.5 IQR内的点，然后独立显示落在该范围之外的观测值。 重要的是，这意味着boxplot中的每个值的显示都对应于数据中的实际观察值：</p>
<blockquote>
<p>未禾备注：IQR即统计学概念四分位距，第一四分位与第三四分位之间的距离，具体内容请参考更深入的相关资料</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.boxplot(x=&quot;day&quot;, y=&quot;total_bill&quot;, hue=&quot;time&quot;, data=tips);</span><br></pre></td></tr></table></figure>
<p><img src="https://pic3.zhimg.com/80/v2-25ccd01314cb4edc937940a238da92a1_hd.jpg" alt="img"></p>
<h2 id="提琴图"><a href="#提琴图" class="headerlink" title="提琴图"></a>提琴图</h2><p>不同的方法是一个violinplot()，它结合了箱体图和分布教程中描述的核心密度估计过程：</p>
<blockquote>
<p>未禾备注：核密度估计，即全文中提到的，或参数内传入的kde，具体概念内容请参考相关文档</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.violinplot(x=&quot;total_bill&quot;, y=&quot;day&quot;, hue=&quot;time&quot;, data=tips);</span><br></pre></td></tr></table></figure>
<p><img src="https://pic1.zhimg.com/80/v2-6d411abcbe8dd7f6388423f82368b690_hd.jpg" alt="img"></p>
<p>这种方法使用核密度估计来更好地描述值的分布。此外，小提琴内还显示了箱体四分位数和晶须值。由于小提琴使用KDE，还有一些其他可以调整的参数，相对于简单的boxplot增加了一些复杂性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sns.violinplot(x=&quot;total_bill&quot;, y=&quot;day&quot;, hue=&quot;time&quot;, data=tips,</span><br><span class="line">               bw=.1, scale=&quot;count&quot;, scale_hue=False);</span><br></pre></td></tr></table></figure>
<p><img src="https://pic1.zhimg.com/80/v2-5e8455c06422bf0722c1308c4b8fa1a8_hd.jpg" alt="img"></p>
<p>当色调参数只有两个级别时，也可以传入参数split至violinplot()，这样可以更有效地利用空间：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.violinplot(x=&quot;day&quot;, y=&quot;total_bill&quot;, hue=&quot;sex&quot;, data=tips, split=True);</span><br></pre></td></tr></table></figure>
<p><img src="https://pic2.zhimg.com/80/v2-6a9d8b2e3db2c42168243d803138231a_hd.jpg" alt="img"></p>
<p>最后，在绘制提琴图的时候有几个选项，包括显示每个人的观察结果而不是总结框图值的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sns.violinplot(x=&quot;day&quot;, y=&quot;total_bill&quot;, hue=&quot;sex&quot;, data=tips,</span><br><span class="line">               split=True, inner=&quot;stick&quot;, palette=&quot;Set3&quot;);</span><br></pre></td></tr></table></figure>
<p><img src="https://pic2.zhimg.com/80/v2-05a4031ae91989627f25233eeac6f506_hd.jpg" alt="img"></p>
<p>将swarmplot()或者swarmplot()与violinplot()或boxplot()结合使用可以显示每个观察结果以及分布的摘要：</p>
<blockquote>
<p>未禾备注：说实话，并不推荐这么做，过多的信息除了炫技没有什么实际用处。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sns.violinplot(x=&quot;day&quot;, y=&quot;total_bill&quot;, data=tips, inner=None)</span><br><span class="line">sns.swarmplot(x=&quot;day&quot;, y=&quot;total_bill&quot;, data=tips, color=&quot;w&quot;, alpha=.5);</span><br></pre></td></tr></table></figure>
<p><img src="https://pic2.zhimg.com/80/v2-295c5b7b5c1a2b1f672265e64596ce1e_hd.jpg" alt="img"></p>
<h2 id="类别内的统计估计"><a href="#类别内的统计估计" class="headerlink" title="类别内的统计估计"></a>类别内的统计估计</h2><p>通常，不是显示每个类别中的分布，你可能希望显示值的集中趋势。 Seaborn有两种显示此信息的主要方法，但重要的是，这些功能的基本API与上述相同。（未禾：这是多么令人愉悦的事情）</p>
<h2 id="条形图"><a href="#条形图" class="headerlink" title="条形图"></a>条形图</h2><p>最熟悉的方式完成这个目标是一个条形图。 在Seaborn中barplot()函数在完整数据集上运行，并显示任意估计，默认情况下使用均值。 当在每个类别中有多个观察值时，它还使用引导来计算估计周围的置信区间，并绘制使用误差条：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.barplot(x=&quot;sex&quot;, y=&quot;survived&quot;, hue=&quot;class&quot;, data=titanic);</span><br></pre></td></tr></table></figure>
<p><img src="https://pic3.zhimg.com/80/v2-1318b9238be523bd01194cf7bb416261_hd.jpg" alt="img"></p>
<p>条形图的特殊情况是当您想要显示每个类别中的观察次数，而不是计算第二个变量的统计量。这类似于分类而不是定量变量的直方图。在Seaborn中，使用countplot()函数很容易绘制：</p>
<blockquote>
<p>未禾备注：函数将默认使用count参数作为x/y中未传的一组维度</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.countplot(x=&quot;deck&quot;, data=titanic, palette=&quot;Greens_d&quot;);</span><br></pre></td></tr></table></figure>
<p><img src="https://pic3.zhimg.com/80/v2-7b236c7baa6138d39982c3a5af64c9e6_hd.jpg" alt="img"></p>
<p>可以使用上面讨论的所有选项来调用barplot()和countplot()，以及在每个函数的详细文档中的其他选项：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.countplot(y=&quot;deck&quot;, hue=&quot;class&quot;, data=titanic, palette=&quot;Greens_d&quot;);</span><br></pre></td></tr></table></figure>
<p><img src="https://pic2.zhimg.com/80/v2-8a4d0f0fdd1a829ec2d7c1bf9a75f428_hd.jpg" alt="img"></p>
<h2 id="点图"><a href="#点图" class="headerlink" title="点图"></a>点图</h2><p>pointplot()函数提供了可视化相同信息的另一种风格。该函数还对另一轴的高度估计值进行编码，而不是显示一个完整的柱型，它只绘制点估计和置信区间。另外，点图连接相同hue类别的点。这使得很容易看出主要关系如何随着第二个变量的变化而变化，因为你的眼睛很好地收集斜率的差异：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.pointplot(x=&quot;sex&quot;, y=&quot;survived&quot;, hue=&quot;class&quot;, data=titanic);</span><br></pre></td></tr></table></figure>
<p><img src="https://pic1.zhimg.com/80/v2-e34242c920fa9cba8a1c8063aa1dab02_hd.jpg" alt="img"></p>
<p>为了使能够在黑白中重现的图形，可以使用不同的标记和线条样式来展示不同hue类别的层次:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sns.pointplot(x=&quot;class&quot;, y=&quot;survived&quot;, hue=&quot;sex&quot;, data=titanic,</span><br><span class="line">              palette=&#123;&quot;male&quot;: &quot;g&quot;, &quot;female&quot;: &quot;m&quot;&#125;,</span><br><span class="line">              markers=[&quot;^&quot;, &quot;o&quot;], linestyles=[&quot;-&quot;, &quot;--&quot;]);</span><br></pre></td></tr></table></figure>
<p><img src="https://pic1.zhimg.com/80/v2-30587c2b5672554dc53fdc562afbe879_hd.jpg" alt="img"></p>
<h2 id="绘制“宽格式”数据"><a href="#绘制“宽格式”数据" class="headerlink" title="绘制“宽格式”数据"></a>绘制“宽格式”数据</h2><p>虽然使用“长格式”或“整洁”数据是优选的，但是这些功能也可以应用于各种格式的“宽格式”数据，包括pandas DataFrame或二维numpy数组阵列。这些对象应该直接传递给数据参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.boxplot(data=iris,orient=&quot;h&quot;);</span><br></pre></td></tr></table></figure>
<p><img src="https://pic2.zhimg.com/80/v2-c5b73ff1bd2922a3b2ecc4f0993ccaef_hd.jpg" alt="img"></p>
<p>此外，这些函数接受Pandas或numpy对象的向量，而不是DataFrame中的变量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.violinplot(x=iris.species, y=iris.sepal_length);</span><br></pre></td></tr></table></figure>
<p><img src="https://pic1.zhimg.com/80/v2-fa08b00797eb9ab1ac7676f572b7ed12_hd.jpg" alt="img"></p>
<p>为了控制由上述功能制作的图形的大小和形状，您必须使用matplotlib命令自己设置图形。 当然，这也意味着这些图块可以和其他种类的图块一起在一个多面板的绘制中共存：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f, ax = plt.subplots(figsize=(7, 3))</span><br><span class="line">sns.countplot(y=&quot;deck&quot;, data=titanic, color=&quot;c&quot;);</span><br></pre></td></tr></table></figure>
<p><img src="https://pic3.zhimg.com/80/v2-0c0966051a5d01b14fb7f1adfcfc2646_hd.jpg" alt="img"></p>
<h2 id="绘制多层面板分类图"><a href="#绘制多层面板分类图" class="headerlink" title="绘制多层面板分类图"></a>绘制多层面板分类图</h2><p>正如我们上面提到的，有两种方法可以在Seaborn中绘制分类图。与回归图中的二元性相似，您可以使用上面介绍的函数，也可以使用更高级别的函数factorplot()，将这些函数与FacetGrid()相结合，通过这个图形的更大的结构来增加展示其他类别的能力。 默认情况下，factorplot()产生一个pairplot()：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.factorplot(x=&quot;day&quot;, y=&quot;total_bill&quot;, hue=&quot;smoker&quot;, data=tips);</span><br></pre></td></tr></table></figure>
<p><img src="https://pic3.zhimg.com/80/v2-d3e754236b6dd7f89e02eaadf26b566a_hd.jpg" alt="img"></p>
<p>然而，kind参数可以让您选择以上讨论的任何种类的图：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.factorplot(x=&quot;day&quot;, y=&quot;total_bill&quot;, hue=&quot;smoker&quot;, data=tips, kind=&quot;bar&quot;);</span><br></pre></td></tr></table></figure>
<p><img src="https://pic4.zhimg.com/80/v2-1abe66cca352c63bd0a17d7e7c49f038_hd.jpg" alt="img"></p>
<p>使用factorplot()的主要优点是很容易调用”facet”展开更多其他分类变量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sns.factorplot(x=&quot;day&quot;, y=&quot;total_bill&quot;, hue=&quot;smoker&quot;,</span><br><span class="line">               col=&quot;time&quot;, data=tips, kind=&quot;swarm&quot;);</span><br></pre></td></tr></table></figure>
<p><img src="https://pic2.zhimg.com/80/v2-48222058fd4ab295854bcc3d8ffba410_hd.jpg" alt="img"></p>
<p>任何一种图形都可以画出来。基于FacetGrid的工作原理，要更改图形的大小和形状，需要指定适用于每个方面的size和aspect参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sns.factorplot(x=&quot;time&quot;, y=&quot;total_bill&quot;, hue=&quot;smoker&quot;,</span><br><span class="line">               col=&quot;day&quot;, data=tips, kind=&quot;box&quot;, size=4, aspect=.5);</span><br></pre></td></tr></table></figure>
<p><img src="https://pic1.zhimg.com/80/v2-7a41b90a994fe70bf463cb70b04db49d_hd.jpg" alt="img"></p>
<p>重要的是要注意，你也可以直接使用boxplot()和FacetGrid来制作这个图。但是，必须特别注意确保分类变量的顺序在每个方面实施，方法是使用具有Categorical数据类型的数据或通过命令和hue_order。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sns.factorplot(x=&quot;time&quot;, y=&quot;total_bill&quot;, hue=&quot;smoker&quot;,hue_order=[&quot;No&quot;,&quot;Yes&quot;]</span><br><span class="line">               ,col=&quot;day&quot;, data=tips, kind=&quot;box&quot;, size=4, aspect=.5,</span><br><span class="line">              palette=&quot;Set3&quot;);</span><br></pre></td></tr></table></figure>
<p><img src="https://pic2.zhimg.com/80/v2-9a1be10821466554a2f7b171973133fe_hd.jpg" alt="img"></p>
<p>由于分类图的广义API，它们应该很容易应用于其他更复杂的上下文。 例如，它们可以轻松地与PairGrid结合，以显示多个不同变量之间的分类关系：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">g = sns.PairGrid(tips,</span><br><span class="line">                 x_vars=[&quot;smoker&quot;, &quot;time&quot;, &quot;sex&quot;],</span><br><span class="line">                 y_vars=[&quot;total_bill&quot;, &quot;tip&quot;],</span><br><span class="line">                 aspect=.75, size=3.5)</span><br><span class="line">g.map(sns.violinplot, palette=&quot;pastel&quot;);</span><br></pre></td></tr></table></figure>
<p><img src="https://pic3.zhimg.com/80/v2-3600c1e18a1f822a6cf03f98d51a6a9e_hd.jpg" alt="img"></p>
<h2 id="补充资料"><a href="#补充资料" class="headerlink" title="补充资料"></a>补充资料</h2><p>最后在这章翻译结束后，未禾专门收集了这个重要函数的所有参数说明，方便参考：</p>
<p>seaborn.factorplot(x=None, y=None, hue=None, data=None, row=None, col=None, col_wrap=None, estimator=<function mean="">, ci=95, n_boot=1000, units=None, order=None, hue_order=None, row_order=None, col_order=None, kind=’point’, size=4, aspect=1, orient=None, color=None, palette=None, legend=True, legend_out=True, sharex=True, sharey=True, margin_titles=False, facet_kws=None, **kwargs)</function></p>
<p>Parameters：</p>
<ul>
<li>x,y,hue 数据集变量 变量名</li>
<li>date 数据集 数据集名</li>
<li>row,col 更多分类变量进行平铺显示 变量名</li>
<li>col_wrap 每行的最高平铺数 整数</li>
<li>estimator 在每个分类中进行矢量到标量的映射 矢量</li>
<li>ci 置信区间 浮点数或None</li>
<li>n_boot 计算置信区间时使用的引导迭代次数 整数</li>
<li>units 采样单元的标识符，用于执行多级引导和重复测量设计 数据变量或向量数据</li>
<li>order, hue_order 对应排序列表 字符串列表</li>
<li>row_order, col_order 对应排序列表 字符串列表</li>
<li>kind : 可选：point 默认, bar 柱形图, count 频次, box 箱体, violin 提琴, strip 散点，swarm 分散点（具体图形参考文章前部的分类介绍）</li>
<li>size 每个面的高度（英寸） 标量</li>
<li>aspect 纵横比 标量</li>
<li>orient 方向 “v”/“h”</li>
<li>color 颜色 matplotlib颜色</li>
<li>palette 调色板 seaborn颜色色板或字典</li>
<li>legend hue的信息面板 True/False</li>
<li>legend_out 是否扩展图形，并将信息框绘制在中心右边 True/False</li>
<li>share{x,y} 共享轴线 True/False</li>
<li>facet_kws <a href="https://link.zhihu.com/?target=http%3A//seaborn.pydata.org/generated/seaborn.FacetGrid.html%23seaborn.FacetGrid" target="_blank" rel="noopener">FacetGrid</a>的其他参数 字典</li>
</ul>
<h2 id="感慨"><a href="#感慨" class="headerlink" title="感慨"></a>感慨</h2><p>终于抽时间把最重要的三章翻译完了，有了这三章seaborn在数据挖掘中已经可以覆盖到大部分数据格式，其快速做图能力已经可以得到足量的发挥。最近工作压力日趋增大，全文还有最难翻译的一章，会坚持在最近放出。最后吐槽下知乎的排版，代码+贴图非常不方便，费时费力唉。</p>
<p>如果文章对你有帮助，请不吝点个赞，方便更多的小伙伴能看到。</p>
<p>如果文章有理解、翻译谬误请留言，十分感谢！</p>
<p>【第五章完】</p>
<h2 id="绘制数据网格"><a href="#绘制数据网格" class="headerlink" title="绘制数据网格"></a>绘制数据网格</h2><p>在探索中等维度数据时，一个有用的方法是在数据集的不同子集上绘制相同绘图的多个实例。这种技术有时被称为“格子”或“格子”绘图，它与“小倍数”的想法有关。 它允许观看者快速提取大量关于复杂数据的信息。 Matplotlib可以很好地支持制作具有多个轴的图形; seaborn建立在此之上，以将结构直接链接到数据集结构上进行绘制。</p>
<p>要使用这些功能，您的数据必须位于Pandas DataFrame中，并且必须采用Hadley Whickam称为“整洁”数据的形式。 简而言之，这意味着您的数据框架应该被结构化，使得每一列都是一个变量，每一行都是一个观测。</p>
<p>对于高级使用，您可以直接使用本教程本部分中讨论的对象，这将提供最大的灵活性。一些Seaborn功能（如lmplot()，factorplot()和pairplot()）也在幕后使用。与其他Seaborn功能“Axes级别”不同，并且绘制在特定（可能已经存在的）matplotlib轴上，而无需其他操作的图形，这些较高级别的功能在调用时创建一个数字，并且通常更严格地说明如何设置。在某些情况下，对于这些函数或其依赖的类的构造函数的参数将提供与图形大小不同的接口属性，如lmplot()的情况，您可以在其中设置每个方面的高度和纵横比而不是整体尺寸。使用这些对象之一的任何函数总是在绘制之后返回，而且这些对象中的大多数都具有方便的方法来改变绘制，通常以更抽象和简单的方式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">%matplotlib inline</span><br><span class="line">import numpy as np</span><br><span class="line">import pandas as pd</span><br><span class="line">import seaborn as sns</span><br><span class="line">from scipy import stats</span><br><span class="line">import matplotlib as mpl</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line"></span><br><span class="line">sns.set(style=&quot;ticks&quot;)</span><br><span class="line">np.random.seed(sum(map(ord, &quot;axis_grids&quot;)))</span><br></pre></td></tr></table></figure>
<h2 id="用FacetGrid子集数据"><a href="#用FacetGrid子集数据" class="headerlink" title="用FacetGrid子集数据"></a>用FacetGrid子集数据</h2><p>当您想要在数据集的子集内可视化变量的分布或多个变量之间的关系时，FacetGrid类很有用。 FacetGrid可以绘制最多三个维度：row，col和hue。前两者与所得轴数有明显的对应关系;将hue变量视为沿着深度轴的第三维，其中不同的级别用不同的颜色绘制。</p>
<p>通过使用数据框初始化FacetGrid对象和将形成网格的行，列或色调维度的变量的名称来使用该类。 这些变量应该是分类的或离散的，然后变量的每个级别的数据将用于沿该轴的小平面。 例如，假设我们要检查tips数据集中的午餐和晚餐之间的差异。</p>
<p>另外，lmplot()和factorplot()在内部使用这个对象，并且当它们被修改时，它们返回该对象，以便可以用于进一步的调整。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tips = sns.load_dataset(&quot;tips&quot;)</span><br><span class="line">tips.head()</span><br></pre></td></tr></table></figure>
<p>total_billtipsexsmokerdaytimesize016.991.01FemaleNoSunDinner 2110.341.66MaleNoSunDinner 3221.013.50MaleNoSunDinner 3323.683.31MaleNoSunDinner 2424.593.61FemaleNoSunDinner 4</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g = sns.FacetGrid(tips, col=&quot;time&quot;)</span><br></pre></td></tr></table></figure>
<p><img src="https://pic4.zhimg.com/80/v2-9f2b5608361b97c070b7875ce83b9e9b_hd.jpg" alt="img"></p>
<p>像这样初始化网格设置了matplotlib图形和轴，但并没有绘制任何东西。</p>
<p>在此网格上可视化数据的主要方法是使用FacetGrid.map()方法，提供一个绘图功能和数据框中变量的名称来绘制。我们来看一下这些子集中提示的分布，使用直方图。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g = sns.FacetGrid(tips, col=&quot;time&quot;)</span><br><span class="line">g.map(plt.hist, &quot;tip&quot;);</span><br></pre></td></tr></table></figure>
<p><img src="https://pic3.zhimg.com/80/v2-5889caed930f8e6456e0f5436f417bf0_hd.jpg" alt="img"></p>
<p>此功能将绘制图形并注释轴，并在一个步骤中生成完成。 要做一个关系图，只需传递多个变量名。可以提供关键字参数，将其传递给绘图功能：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">g = sns.FacetGrid(tips, col=&quot;sex&quot;, hue=&quot;smoker&quot;)</span><br><span class="line">g.map(plt.scatter, &quot;total_bill&quot;, &quot;tip&quot;, alpha=.7)</span><br><span class="line">g.add_legend();</span><br></pre></td></tr></table></figure>
<p><img src="https://pic4.zhimg.com/80/v2-dd190201252b6e703f0aa27ccf3ef8d8_hd.jpg" alt="img"></p>
<p>有几个选项可以控制可以传递给类构造函数的网格的外观。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g = sns.FacetGrid(tips, row=&quot;smoker&quot;, col=&quot;time&quot;, margin_titles=True)</span><br><span class="line">g.map(sns.regplot, &quot;size&quot;, &quot;total_bill&quot;, color=&quot;.3&quot;, fit_reg=False, x_jitter=.1);</span><br></pre></td></tr></table></figure>
<p><img src="https://pic3.zhimg.com/80/v2-550f3934b37563c402583046f2ecfa00_hd.jpg" alt="img"></p>
<p>请注意，matplotlib API没有正式支持margin_titles，并且在所有情况下都可能无法正常运行。 特别是，它目前不能用于图形之外的注释框。</p>
<p>通过提供每个图形的高度以及纵横比来达到设置图形大小的目的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g = sns.FacetGrid(tips, col=&quot;day&quot;, size=4, aspect=.5)</span><br><span class="line">g.map(sns.barplot, &quot;sex&quot;, &quot;total_bill&quot;);</span><br></pre></td></tr></table></figure>
<p><img src="https://pic3.zhimg.com/80/v2-8bf26ec7f1b62170664af09f1ac0ed1f_hd.jpg" alt="img"></p>
<p>在matplotlib大于1.4的版本中，可以传递在gridspec模块中的参数，增加其尺寸来吸引注意力。当然，在每个方面可视化不同数量的组的数据集的分布时，这无疑是特别实用的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">titanic = sns.load_dataset(&quot;titanic&quot;)</span><br><span class="line">titanic = titanic.assign(deck=titanic.deck.astype(object)).sort_values(&quot;deck&quot;)</span><br><span class="line">g = sns.FacetGrid(titanic, col=&quot;class&quot;, sharex=False,</span><br><span class="line">                  gridspec_kws=&#123;&quot;width_ratios&quot;: [5, 3, 3]&#125;)</span><br><span class="line">g.map(sns.boxplot, &quot;deck&quot;, &quot;age&quot;);</span><br></pre></td></tr></table></figure>
<p><img src="https://pic3.zhimg.com/80/v2-88d412cb9e91f29e5925c7ddd661af4f_hd.jpg" alt="img"></p>
<p>这里，默认的顺序来自于DataFrame中的书序。如果用于定义facets具有分类变量的类型，则会实用类别的顺序。否则，facets将按照级别的顺序排列。当然，也可以使用适当的*_order参数来指定任何平面维度的数据顺序。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ordered_days = tips.day.value_counts().index</span><br><span class="line">g = sns.FacetGrid(tips, row=&quot;day&quot;, row_order=ordered_days,</span><br><span class="line">                  size=1.7, aspect=4,)</span><br><span class="line">g.map(sns.distplot, &quot;total_bill&quot;, hist=False, rug=True);</span><br></pre></td></tr></table></figure>
<p><img src="https://pic2.zhimg.com/80/v2-18b5561a458d45ccd80ce1d75f84a9ea_hd.jpg" alt="img"></p>
<p>可以提供任何Seaborn调色板（即可以传递给color_palette()的参数），还可以使用将色调变量中值的名称映射到有效的matplotlib颜色的字典：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pal = dict(Lunch=&quot;seagreen&quot;, Dinner=&quot;gray&quot;)</span><br><span class="line">g = sns.FacetGrid(tips, hue=&quot;time&quot;, palette=pal, size=5)</span><br><span class="line">g.map(plt.scatter, &quot;total_bill&quot;, &quot;tip&quot;, s=50, alpha=.7, linewidth=.5, edgecolor=&quot;white&quot;)</span><br><span class="line">g.add_legend();</span><br></pre></td></tr></table></figure>
<p><img src="https://pic1.zhimg.com/80/v2-46c8d268396fda740c3f3e0aa96ee0c7_hd.jpg" alt="img"></p>
<p>您还可以让色调的其他方面在色相变量的水平上有所不同，这对于绘制黑白打印时将更易于理解的图形将有所帮助。 为此，将字典传递给hue_kws，其中键是绘图函数关键字参数的名称，值是关键字值的列表，每个级别的hue对应一个变量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">g = sns.FacetGrid(tips, hue=&quot;sex&quot;, palette=&quot;Set1&quot;, size=5, hue_kws=&#123;&quot;marker&quot;: [&quot;^&quot;, &quot;v&quot;]&#125;)</span><br><span class="line">g.map(plt.scatter, &quot;total_bill&quot;, &quot;tip&quot;, s=100, linewidth=.5, edgecolor=&quot;white&quot;)</span><br><span class="line">g.add_legend();</span><br></pre></td></tr></table></figure>
<p><img src="https://pic1.zhimg.com/80/v2-8a74573c377e77af4ac699ac8ab1d07d_hd.jpg" alt="img"></p>
<p>如果您有多个级别的一个变量，您可以沿着列绘制，但是”wrap”它们，以便跨越多个行。 当这样做时，将不能使用行(row)变量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">attend = sns.load_dataset(&quot;attention&quot;).query(&quot;subject &lt;= 12&quot;)</span><br><span class="line">g = sns.FacetGrid(attend, col=&quot;subject&quot;, col_wrap=4, size=2, ylim=(0, 10))</span><br><span class="line">g.map(sns.pointplot, &quot;solutions&quot;, &quot;score&quot;, color=&quot;.3&quot;, ci=None);</span><br></pre></td></tr></table></figure>
<p><img src="https://pic2.zhimg.com/80/v2-0ac8d99ee4bed79a89b5f5abcd0bf161_hd.jpg" alt="img"></p>
<p>使用FacetGrid.map()（可以多次调用）绘制图形之后，您可能需要调整绘图的某些方面。 FacetGrid对象上还有一些方法可以在更高层次的抽象上操作图形。 最通用的是FacetGrid.set()，还有其他更专门的方法，如FacetGrid.set_axis_labels()，它遵循内部方面没有轴标签的效果。 例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">with sns.axes_style(&quot;white&quot;):</span><br><span class="line">    g = sns.FacetGrid(tips, row=&quot;sex&quot;, col=&quot;smoker&quot;, margin_titles=True, size=2.5)</span><br><span class="line">g.map(plt.scatter, &quot;total_bill&quot;, &quot;tip&quot;, color=&quot;#334488&quot;, edgecolor=&quot;white&quot;, lw=.5);</span><br><span class="line">g.set_axis_labels(&quot;Total bill (US Dollars)&quot;, &quot;Tip&quot;);</span><br><span class="line">g.set(xticks=[10, 30, 50], yticks=[2, 6, 10]);</span><br><span class="line">g.fig.subplots_adjust(wspace=.02, hspace=.02);</span><br></pre></td></tr></table></figure>
<p><img src="https://pic3.zhimg.com/80/v2-ba89152565892ede64bd0374023bf980_hd.jpg" alt="img"></p>
<p>对于更多的定制，您可以直接使用underling matplotlib图形和Axes对象，它们分别作为图和轴（二维数组）的成员属性存储。 当没有行或列面的图形时，还可以使用ax属性直接访问单个轴。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">g = sns.FacetGrid(tips, col=&quot;smoker&quot;, margin_titles=True, size=4)</span><br><span class="line">g.map(plt.scatter, &quot;total_bill&quot;, &quot;tip&quot;, color=&quot;#338844&quot;, edgecolor=&quot;white&quot;, s=50, lw=1)</span><br><span class="line">for ax in g.axes.flat:</span><br><span class="line">    ax.plot((0, 50), (0, .2 * 50), c=&quot;.2&quot;, ls=&quot;--&quot;)</span><br><span class="line">g.set(xlim=(0, 60), ylim=(0, 14));</span><br></pre></td></tr></table></figure>
<p><img src="https://pic2.zhimg.com/80/v2-3fed5e7268b4d3d86c908828fafba138_hd.jpg" alt="img"></p>
<h2 id="将自定义函数应用在网格上"><a href="#将自定义函数应用在网格上" class="headerlink" title="将自定义函数应用在网格上"></a>将自定义函数应用在网格上</h2><p>在使用FacetGrid时，并不限于现有的matplotlib和Seaborn功能。但是，要正常工作，使用必须遵循以下规则：</p>
<ol>
<li>必须绘制在“当前活动”的matplotlib轴上。 这对matplotlib.pyplot命名空间中的函数是正确的，如果要使用其方法，可以调用plt.gca来获取对当前Axes的直接引用。</li>
<li>它必须接受它在位置参数中绘制的数据。 在内部，FacetGrid将传递一系列针对传递给FacetGrid.map()的命名位置参数的数据。</li>
<li>它必须能够接受color和label关键字参数，理想情况下它将非常有用。在大多数情况下，使用一个通用的**kwargs字典是最简单的，并将其传递给底层的绘图函数。</li>
</ol>
<p>我们来看一下您可以绘制的功能的最简单的例子。该函数只需要给出每个方向的向量的数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def quantile_plot(x, **kwargs):</span><br><span class="line">    qntls, xr = stats.probplot(x, fit=False)</span><br><span class="line">    plt.scatter(xr, qntls, **kwargs)</span><br><span class="line"></span><br><span class="line">g = sns.FacetGrid(tips, col=&quot;sex&quot;, size=4)</span><br><span class="line">g.map(quantile_plot, &quot;total_bill&quot;);</span><br></pre></td></tr></table></figure>
<p><img src="https://pic4.zhimg.com/80/v2-80ed14890b57bc617c6493cbc8fff50c_hd.jpg" alt="img"></p>
<p>如果我们想做一个双变量图，你应该编写函数，以便它接受x轴为第一个变量和y轴为第二个变量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def qqplot(x, y, **kwargs):</span><br><span class="line">    _, xr = stats.probplot(x, fit=False)</span><br><span class="line">    _, yr = stats.probplot(y, fit=False)</span><br><span class="line">    plt.scatter(xr, yr, **kwargs)</span><br><span class="line"></span><br><span class="line">g = sns.FacetGrid(tips, col=&quot;smoker&quot;, size=4)</span><br><span class="line">g.map(qqplot, &quot;total_bill&quot;, &quot;tip&quot;);</span><br></pre></td></tr></table></figure>
<p><img src="https://pic2.zhimg.com/80/v2-f4ee5c76f8143f72924da221976adf62_hd.jpg" alt="img"></p>
<p>因为plt.scatter接受color和label关键字参数并正确运行，我们可以简单的再添加一个hue参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">g = sns.FacetGrid(tips, hue=&quot;time&quot;, col=&quot;sex&quot;, size=4)</span><br><span class="line">g.map(qqplot, &quot;total_bill&quot;, &quot;tip&quot;)</span><br><span class="line">g.add_legend();</span><br></pre></td></tr></table></figure>
<p><img src="https://pic3.zhimg.com/80/v2-5fc741b1c3808d9446f8e2da9019b6fc_hd.jpg" alt="img"></p>
<p>这种方法还允许我们使用额外的sns设置来区分hue变量的级别，依赖这些关键字的参数将使得显示摆脱对刻面变量的依赖：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">g = sns.FacetGrid(tips, hue=&quot;time&quot;, col=&quot;sex&quot;, size=4,</span><br><span class="line">                  hue_kws=&#123;&quot;marker&quot;: [&quot;s&quot;, &quot;D&quot;]&#125;)</span><br><span class="line">g.map(qqplot, &quot;total_bill&quot;, &quot;tip&quot;, s=40, edgecolor=&quot;w&quot;)</span><br><span class="line">g.add_legend();</span><br></pre></td></tr></table></figure>
<p><img src="https://pic3.zhimg.com/80/v2-8a7d63e43590a4859faaed76a4d6dabd_hd.jpg" alt="img"></p>
<p>一些时候，将需要映射一个适合的color和label关键字参数以达到预期的效果。在这种情况下，您将会有明确地把握并熟悉处理自定义函数的逻辑。例如这种方法将允许使用映射plt.hexbin函数和那些类似的不方便使用FacetGrid API的调用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def hexbin(x, y, color, **kwargs):</span><br><span class="line">    cmap = sns.light_palette(color, as_cmap=True)</span><br><span class="line">    plt.hexbin(x, y, gridsize=15, cmap=cmap, **kwargs)</span><br><span class="line"></span><br><span class="line">with sns.axes_style(&quot;dark&quot;):</span><br><span class="line">    g = sns.FacetGrid(tips, hue=&quot;time&quot;, col=&quot;time&quot;, size=4)</span><br><span class="line">g.map(hexbin, &quot;total_bill&quot;, &quot;tip&quot;, extent=[0, 50, 0, 10]);</span><br></pre></td></tr></table></figure>
<p><img src="https://pic4.zhimg.com/80/v2-977af27c7a944bdbddd261133b670150_hd.jpg" alt="img"></p>
<h2 id="用PairGrid-and-pairplot-绘制成对的关系"><a href="#用PairGrid-and-pairplot-绘制成对的关系" class="headerlink" title="用PairGrid and pairplot()绘制成对的关系"></a>用PairGrid and pairplot()绘制成对的关系</h2><p>PairGrid还允许您使用相同的绘图类型快速绘制小子图的网格，以在每个图形中显示数据。在一个PairGrid中，每个行和列分配给一个不同的变量，所以生成的图显示了数据集中的每个成对关系。这种风格的绘图有时被称为“散点图矩阵”，因为这是显示每个关系的最常见方式，但是PairGrid不仅限于散点图。</p>
<p>了解FacetGrid和PairGrid之间的区别很重要。在前者中，每个方面显示出与其他变量的不同级别相同的关系。在后者中，每个图都显示不同的关系（尽管上下三角形将具有镜像图）。使用PairGrid可以为您提供非常快速，非常高级的汇总数据集中有趣的关系。</p>
<p>该类的基本用法与FacetGrid非常相似。首先初始化网格，然后将绘图函数传递给map方法，并在每个子图上调用它。还有一个配套功能，pairplot（）交易了一些灵活性更快的绘图。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">iris = sns.load_dataset(&quot;iris&quot;)</span><br><span class="line">g = sns.PairGrid(iris)</span><br><span class="line">g.map(plt.scatter);</span><br></pre></td></tr></table></figure>
<p><img src="https://pic3.zhimg.com/80/v2-66aa5c89da0590b8df1fb1aaaa27bc05_hd.jpg" alt="img"></p>
<p>可以在对角线上绘制不同的函数，以显示每列中变量的单变量分布。 请注意，轴刻度线将不对应于该图的计数或密度轴。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">g = sns.PairGrid(iris)</span><br><span class="line">g.map_diag(plt.hist)</span><br><span class="line">g.map_offdiag(plt.scatter);</span><br></pre></td></tr></table></figure>
<p><img src="https://pic3.zhimg.com/80/v2-7d38ba75d236d8825de65263e38bbabc_hd.jpg" alt="img"></p>
<p>使用该图的非常常见的方法是通过单独的分类变量来绘制观察值。 例如，虹膜数据集对于三种不同种类的鸢尾花中的每一种进行四次测量，以便您可以看到它们如何不同。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">g = sns.PairGrid(iris, hue=&quot;species&quot;)</span><br><span class="line">g.map_diag(plt.hist)</span><br><span class="line">g.map_offdiag(plt.scatter)</span><br><span class="line">g.add_legend();</span><br></pre></td></tr></table></figure>
<p><img src="https://pic4.zhimg.com/80/v2-c8f204087140c869503ab1c64f5b764d_hd.jpg" alt="img"></p>
<p>默认情况下，使用数据集中的每个数字列，但如果需要，您可以专注于特定的关系。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g = sns.PairGrid(iris, vars=[&quot;sepal_length&quot;, &quot;sepal_width&quot;], hue=&quot;species&quot;)</span><br><span class="line">g.map(plt.scatter);</span><br></pre></td></tr></table></figure>
<p><img src="https://pic1.zhimg.com/80/v2-5fd801e317ef34c26e1b0c1872260126_hd.jpg" alt="img"></p>
<p>也可以在上下三角形中使用不同的功能来强调关系的不同方面。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">g = sns.PairGrid(iris)</span><br><span class="line">g.map_upper(plt.scatter)</span><br><span class="line">g.map_lower(sns.kdeplot, cmap=&quot;Blues_d&quot;)</span><br><span class="line">g.map_diag(sns.kdeplot, lw=3, legend=False);</span><br></pre></td></tr></table></figure>
<p><img src="https://pic4.zhimg.com/80/v2-f354d67e2bf8ac1b14f8fe9078524245_hd.jpg" alt="img"></p>
<p>具有对角线上的身份关系的方形网格实际上只是一个特殊情况，您可以在行和列中绘制不同的变量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">g = sns.PairGrid(tips, y_vars=[&quot;tip&quot;], x_vars=[&quot;total_bill&quot;, &quot;size&quot;], size=4)</span><br><span class="line">g.map(sns.regplot, color=&quot;.3&quot;)</span><br><span class="line">g.set(ylim=(-1, 11), yticks=[0, 5, 10]);</span><br></pre></td></tr></table></figure>
<p><img src="https://pic3.zhimg.com/80/v2-16f09c835b8b486e21d3eed601c3ad84_hd.jpg" alt="img"></p>
<p>当然，sns属性是可配置的。 例如，您可以使用不同的调色板（例如，显示色调变量的顺序），并将关键字参数传递到绘图函数中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">g = sns.PairGrid(tips, hue=&quot;size&quot;, palette=&quot;GnBu_d&quot;)</span><br><span class="line">g.map(plt.scatter, s=50, edgecolor=&quot;white&quot;)</span><br><span class="line">g.add_legend();</span><br></pre></td></tr></table></figure>
<p><img src="https://pic3.zhimg.com/80/v2-1cbe14644fb39c93745daea2f5e56a06_hd.jpg" alt="img"></p>
<p>PairGrid是灵活的，但是要快速查看一个数据集，可以使用pairplot()更容易。 默认情况下，该功能使用散点图和直方图，但是还可以添加其他几种（目前还可以绘制对角线上的对角线和KDEs的回归图）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.pairplot(iris, hue=&quot;species&quot;, size=2.5);</span><br></pre></td></tr></table></figure>
<p><img src="https://pic1.zhimg.com/80/v2-e50e0b8bdd127530871188188ea7c8bc_hd.jpg" alt="img"></p>
<p>您还可以使用关键字参数控制显示细节，并返回PairGrid实例进行进一步的调整。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g = sns.pairplot(iris, hue=&quot;species&quot;, palette=&quot;Set2&quot;, diag_kind=&quot;kde&quot;, size=2.5)</span><br></pre></td></tr></table></figure>
<p><img src="https://pic4.zhimg.com/80/v2-099c4a8bac808e3e6d7ba63258d10615_hd.jpg" alt="img"></p>
<p>松了口气，最终全部完成了，没有烂尾。有时间未禾将对每个章节进行再次的校对和注释，感谢诸多朋友的支持和鼓励，闲暇也许还会针对这六章内容出一个快速上手笔记，感谢！</p>
<p>【全文完】</p>

      
    </div>
    
    
    

    

    

    

<div>
  
    <div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------感谢阅读-------------</div>
    
</div>

  
</div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Python/" rel="tag"><i class="fa fa-tag"></i> Python</a>
          
            <a href="/tags/Seaborn/" rel="tag"><i class="fa fa-tag"></i> Seaborn</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/02/07/必备神器之pandas/" rel="next" title="必备神器之pandas">
                <i class="fa fa-chevron-left"></i> 必备神器之pandas
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/02/11/转-吴恩达老师的机器学习课程/" rel="prev" title="转<吴恩达老师的机器学习课程>">
                转<吴恩达老师的机器学习课程> <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
      <div id="sidebar-dimmer"></div>
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="https://avatars3.githubusercontent.com/u/17525031?s=400&u=fab06329bc1d10873fe82aa4c050440ace03202a&v=4"
                alt="KuiyuanZhang" />
            
              <p class="site-author-name" itemprop="name">KuiyuanZhang</p>
              <p class="site-description motion-element" itemprop="description">Stay hungry. Stay foolish.</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">16</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">24</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/KuiyuanZhang" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:kuiyuanzhang@126.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://www.zhihu.com/people/zhang-kui-yuan-53/activities" target="_blank" title="知乎">
                      
                        <i class="fa fa-fw fa-globe"></i>知乎</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://www.jianshu.com/users/a927e8ba8a99/timeline" target="_blank" title="简书">
                      
                        <i class="fa fa-fw fa-globe"></i>简书</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="http://blog.csdn.net/a9192943" target="_blank" title="CSDN">
                      
                        <i class="fa fa-fw fa-globe"></i>CSDN</a>
                  </span>
                
            </div>
          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                Links
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="http://www.baidu.com/" title="百度" target="_blank">百度</a>
                  </li>
                
              </ul>
          <div id="days"></div>
</script>
<script language="javascript">
function show_date_time(){
window.setTimeout("show_date_time()", 1000);
BirthDay=new Date("01/16/2018 00:00:00");
today=new Date();
timeold=(today.getTime()-BirthDay.getTime());
sectimeold=timeold/1000
secondsold=Math.floor(sectimeold);
msPerDay=24*60*60*1000
e_daysold=timeold/msPerDay
daysold=Math.floor(e_daysold);
e_hrsold=(e_daysold-daysold)*24;
hrsold=setzero(Math.floor(e_hrsold));
e_minsold=(e_hrsold-hrsold)*60;
minsold=setzero(Math.floor((e_hrsold-hrsold)*60));
seconds=setzero(Math.floor((e_minsold-minsold)*60));
document.getElementById('days').innerHTML="已运行"+daysold+"天"+hrsold+"小时"+minsold+"分"+seconds+"秒";
}
function setzero(i){
if (i<10)
{i="0" + i};
return i;
}
show_date_time();
</script>

            </div>
          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#import语句"><span class="nav-number">1.</span> <span class="nav-text">import语句</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第一章-艺术化的图表控制"><span class="nav-number"></span> <span class="nav-text">第一章 艺术化的图表控制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#样式控制：axes-style-and-set-style"><span class="nav-number"></span> <span class="nav-text">样式控制：axes_style() and set_style()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#用despine-进行边框控制"><span class="nav-number"></span> <span class="nav-text">用despine()进行边框控制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#临时设定图形样式"><span class="nav-number"></span> <span class="nav-text">临时设定图形样式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#seaborn样式中最重要的元素"><span class="nav-number"></span> <span class="nav-text">seaborn样式中最重要的元素</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#通过-plotting-context-和-set-context-调整绘图元素"><span class="nav-number"></span> <span class="nav-text">通过 plotting_context() 和 set_context() 调整绘图元素</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#通过color-palette-创建调色板"><span class="nav-number"></span> <span class="nav-text">通过color_palette()创建调色板</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#分类色板"><span class="nav-number"></span> <span class="nav-text">分类色板</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用圆形颜色系统"><span class="nav-number"></span> <span class="nav-text">使用圆形颜色系统</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#cubehelix-palette-函数的连续调色板"><span class="nav-number"></span> <span class="nav-text">cubehelix_palette()函数的连续调色板</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用light-palette-和dark-palette-调用定制连续调色板"><span class="nav-number"></span> <span class="nav-text">使用light_palette() 和dark_palette()调用定制连续调色板</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#离散色板"><span class="nav-number"></span> <span class="nav-text">离散色板</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#本章后记"><span class="nav-number"></span> <span class="nav-text">本章后记</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第三章-分布数据集的可视化"><span class="nav-number"></span> <span class="nav-text">第三章 分布数据集的可视化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#单变量分布"><span class="nav-number"></span> <span class="nav-text">单变量分布</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#直方图"><span class="nav-number"></span> <span class="nav-text">直方图</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#核密度估计-KDE-Kernel-density-estimaton"><span class="nav-number"></span> <span class="nav-text">核密度估计(KDE) Kernel density estimaton</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#拟合参数分布"><span class="nav-number"></span> <span class="nav-text">拟合参数分布</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#绘制双变量分布"><span class="nav-number"></span> <span class="nav-text">绘制双变量分布</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#散点图"><span class="nav-number"></span> <span class="nav-text">散点图</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HexBin图"><span class="nav-number"></span> <span class="nav-text">HexBin图</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#核密度估计"><span class="nav-number"></span> <span class="nav-text">核密度估计</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#呈现数据集中成对的关系"><span class="nav-number"></span> <span class="nav-text">呈现数据集中成对的关系</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#绘制线性回归模型的函数"><span class="nav-number"></span> <span class="nav-text">绘制线性回归模型的函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#不同类型的模型拟合"><span class="nav-number"></span> <span class="nav-text">不同类型的模型拟合</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#调节其他变量"><span class="nav-number"></span> <span class="nav-text">调节其他变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#控制绘制的大小和形状"><span class="nav-number"></span> <span class="nav-text">控制绘制的大小和形状</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#在其他背景下绘制回归"><span class="nav-number"></span> <span class="nav-text">在其他背景下绘制回归</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第五章-分类数据的绘制"><span class="nav-number"></span> <span class="nav-text">第五章 分类数据的绘制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#分类散点图"><span class="nav-number"></span> <span class="nav-text">分类散点图</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#分类内的观测分布"><span class="nav-number"></span> <span class="nav-text">分类内的观测分布</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#箱线图"><span class="nav-number"></span> <span class="nav-text">箱线图</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#提琴图"><span class="nav-number"></span> <span class="nav-text">提琴图</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类别内的统计估计"><span class="nav-number"></span> <span class="nav-text">类别内的统计估计</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#条形图"><span class="nav-number"></span> <span class="nav-text">条形图</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#点图"><span class="nav-number"></span> <span class="nav-text">点图</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#绘制“宽格式”数据"><span class="nav-number"></span> <span class="nav-text">绘制“宽格式”数据</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#绘制多层面板分类图"><span class="nav-number"></span> <span class="nav-text">绘制多层面板分类图</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#补充资料"><span class="nav-number"></span> <span class="nav-text">补充资料</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#感慨"><span class="nav-number"></span> <span class="nav-text">感慨</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#绘制数据网格"><span class="nav-number"></span> <span class="nav-text">绘制数据网格</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#用FacetGrid子集数据"><span class="nav-number"></span> <span class="nav-text">用FacetGrid子集数据</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#将自定义函数应用在网格上"><span class="nav-number"></span> <span class="nav-text">将自定义函数应用在网格上</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#用PairGrid-and-pairplot-绘制成对的关系"><span class="nav-number"></span> <span class="nav-text">用PairGrid and pairplot()绘制成对的关系</span></a></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">KuiyuanZhang</span>

  
</div>










<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共43.3k字</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i> 访问人数
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      人次
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i> 访问总量
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

</body>
</html>
